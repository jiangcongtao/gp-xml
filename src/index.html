<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML Navigator</title>
    <!-- Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <!-- Monaco Editor will be loaded dynamically based on environment -->
    <style>
        :root {
            --primary-color: #3b82f6;
            --bg-color: #f3f4f6;
            --panel-bg: #ffffff;
            --text-color: #1f2937;
            --border-color: #e5e7eb;
            --hover-color: #eff6ff;
            --selected-bg: #dbeafe;
            --card-header-bg: #ffffff;
            --table-header-bg: #f8fafc;
            --table-header-text: #64748b;
            --parent-path-bg: #f0f7ff;
            --error-bg: #fef2f2;
            --error-text: #991b1b;
            --error-border: #dc2626;
            --secondary-text: #6b7280;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --primary-color: #60a5fa;
            --bg-color: #111827;
            --panel-bg: #1f2937;
            --text-color: #f9fafb;
            --border-color: #374151;
            --hover-color: #1f2937;
            --selected-bg: #1e3a8a;
            --card-header-bg: #1f2937;
            --table-header-bg: #374151;
            --table-header-text: #9ca3af;
            --parent-path-bg: #1e3a8a;
            --error-bg: #7f1d1d;
            --error-text: #fecaca;
            --error-border: #ef4444;
            --secondary-text: #9ca3af;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header & Upload Area */
        header {
            background: var(--panel-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            gap: 1rem;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        #drop-zone {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: 2px dashed var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem 1.5rem;
            transition: all 0.2s ease;
            cursor: pointer;
            color: var(--text-color);
            font-size: 0.9rem;
            flex: 1;
            min-width: 200px;
            opacity: 0.7;
        }

        #drop-zone .material-symbols-outlined {
            font-size: 1.2rem;
        }

        #drop-zone.dragover {
            border-color: var(--primary-color);
            background-color: var(--hover-color);
            color: var(--primary-color);
            opacity: 1;
        }

        /* Header Controls */
        .header-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .header-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background: var(--panel-bg);
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-color);
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .header-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background-color: var(--hover-color);
            transform: translateY(-1px);
        }

        /* Material Symbols Icons */
        .material-symbols-outlined {
            font-family: 'Material Symbols Outlined';
            font-weight: normal;
            font-style: normal;
            font-size: 1.2rem;
            line-height: 1;
            letter-spacing: normal;
            text-transform: none;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            font-feature-settings: 'liga';
            flex-shrink: 0;
            user-select: none;
        }

        h1 .material-symbols-outlined {
            font-size: 1.5rem;
            margin-right: 0.5rem;
            vertical-align: middle;
        }

        .header-btn .material-symbols-outlined {
            font-size: 1.2rem;
        }

        .view-tab .material-symbols-outlined {
            font-size: 1.2rem;
        }

        /* Main Layout */
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: 100%;
        }

        /* Left Panel: Tree View */
        #tree-panel {
            width: 350px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 1rem;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .tree-node {
            cursor: pointer;
            padding: 4px 0;
            user-select: none;
            white-space: nowrap;
        }

        .tree-content {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .tree-content:hover {
            background-color: var(--hover-color);
        }

        .tree-content.selected {
            background-color: var(--selected-bg);
            color: var(--primary-color);
            font-weight: 500;
        }

        .tree-content.parent-path {
            background-color: var(--parent-path-bg);
            border-left: 3px solid var(--primary-color);
            padding-left: 5px;
        }

        .toggle-icon {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: var(--secondary-text);
            transition: transform 0.2s;
        }

        .expanded > .tree-content > .toggle-icon {
            transform: rotate(90deg);
        }

        .leaf-node .toggle-icon {
            visibility: hidden;
        }

        .node-children {
            padding-left: 20px;
            display: none;
            border-left: 1px solid #f0f0f0;
            margin-left: 7px;
        }

        .expanded > .node-children {
            display: block;
        }

        .tag-name {
            margin-right: 8px;
        }

        /* Tree Panel Controls */
        .tree-controls {
            background: var(--panel-bg);
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            display: none;
            flex-shrink: 0;
            margin: -1rem -1rem 1rem -1rem;
        }

        .tree-controls.visible {
            display: block;
        }

        .tree-search-wrapper {
            margin-bottom: 0.5rem;
        }

        .tree-search-wrapper input {
            width: 100%;
            padding: 0.4rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.85rem;
            background: var(--panel-bg);
            color: var(--text-color);
            transition: all 0.2s;
        }
        
        .tree-search-wrapper input::placeholder {
            color: var(--secondary-text);
            opacity: 0.6;
        }

        .tree-search-wrapper input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .tree-options {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.75rem;
        }

        .tree-scope-group {
            display: flex;
            gap: 0.4rem;
            flex: 1;
        }

        .tree-scope-group label {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            color: var(--secondary-text);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .tree-scope-group input[type="radio"] {
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .tree-sort-btn {
            padding: 0.3rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--panel-bg);
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text-color);
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            white-space: nowrap;
        }

        .tree-sort-btn:hover {
            background-color: var(--hover-color);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .tree-sort-icon {
            font-size: 0.7rem;
        }

        .tree-container {
            flex: 1;
            overflow-y: auto;
        }

        /* Right Panel: Detail View */
        #detail-panel {
            flex: 1;
            padding: 0;
            overflow-y: auto;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
        }

        /* Search Filter Bar */
        .search-filter-bar {
            background: var(--panel-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: none; /* Hidden by default */
            flex-shrink: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .search-filter-bar.visible {
            display: block;
        }

        .search-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-input-wrapper {
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        .search-input-wrapper input {
            width: 100%;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--panel-bg);
            color: var(--text-color);
            transition: all 0.2s;
        }
        
        .search-input-wrapper input::placeholder {
            color: var(--secondary-text);
            opacity: 0.6;
        }

        .search-input-wrapper input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-scope {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .search-scope label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.85rem;
            color: var(--secondary-text);
            cursor: pointer;
            user-select: none;
        }

        .search-scope input[type="radio"] {
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .search-info {
            font-size: 0.8rem;
            color: var(--secondary-text);
            margin-top: 0.5rem;
        }

        .detail-content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--secondary-text);
            text-align: center;
        }

        .detail-card {
            background: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .card-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--card-header-bg);
        }

        .card-header h2 {
            font-size: 1.1rem;
            color: var(--text-color);
        }

        .path-breadcrumb {
            font-size: 0.85rem;
            color: var(--secondary-text);
            margin-top: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            text-align: left;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--table-header-text);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        th.sortable {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.15s;
        }

        th.sortable:hover {
            background-color: var(--hover-color);
        }

        .sort-indicator {
            display: inline-block;
            margin-left: 6px;
            font-size: 0.75rem;
            color: var(--primary-color);
        }

        tr:last-child td {
            border-bottom: none;
        }

        td.attr-name {
            font-weight: 500;
            color: var(--primary-color);
            width: 30%;
        }

        td.attr-value {
            color: #4b5563;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            word-break: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        /* Help Upload Button */
        .help-upload-wrapper {
            display: flex;
            align-items: center;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
        }

        .help-upload-wrapper.dragover {
            transform: scale(1.02);
        }

        .help-upload-wrapper.dragover .help-upload-btn {
            border-color: var(--primary-color);
            border-style: dashed;
            background-color: var(--hover-color);
            color: var(--primary-color);
            opacity: 1;
        }

        .help-upload-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border: 2px dashed var(--border-color);
            border-radius: 0.5rem;
            background: var(--panel-bg);
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-color);
            transition: all 0.2s ease;
            max-width: 280px;
            opacity: 0.7;
        }

        .help-upload-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background-color: var(--hover-color);
            opacity: 1;
        }

        .help-upload-btn.loaded {
            border-color: #10b981;
            border-style: solid;
            color: #10b981;
            background-color: #ecfdf5;
            opacity: 1;
        }

        .help-upload-btn .material-symbols-outlined {
            font-size: 1.2rem;
        }

        #help-status-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Tooltip Styles */
        .help-tooltip {
            position: fixed;
            z-index: 10000;
            max-width: 320px;
            padding: 0;
            background: #1f2937;
            color: #f9fafb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
            font-size: 0.85rem;
            line-height: 1.5;
            pointer-events: none;
            opacity: 0;
            transform: translateY(4px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .help-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .help-tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: var(--arrow-left, 20px);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid #374151;
        }

        .help-tooltip.above::before {
            top: auto;
            bottom: -6px;
            border-bottom: none;
            border-top: 6px solid #1f2937;
        }

        .help-tooltip-header {
            padding: 0.75rem 1rem;
            background: #374151;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            color: #60a5fa;
            border-bottom: 1px solid #4b5563;
        }

        .help-tooltip-error {
            padding: 0.75rem 1rem;
            background: #991b1b;
            color: #fef2f2;
            border-bottom: 1px solid #7f1d1d;
        }

        .help-tooltip-error:first-child {
            border-radius: 8px 8px 0 0;
        }

        .help-tooltip-error-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .help-tooltip-error-title::before {
            content: '⚠️';
        }

        .help-tooltip-error-list {
            margin: 0;
            padding-left: 1.2rem;
            font-size: 0.8rem;
        }

        .help-tooltip-error-list li {
            margin-bottom: 0.25rem;
        }

        .help-tooltip-error-list li:last-child {
            margin-bottom: 0;
        }

        .help-tooltip-error + .help-tooltip-header {
            border-radius: 0;
        }

        .help-tooltip-body {
            padding: 0.75rem 1rem;
        }

        .help-tooltip-row {
            display: flex;
            margin-bottom: 0.5rem;
        }

        .help-tooltip-row:last-child {
            margin-bottom: 0;
        }

        .help-tooltip-label {
            flex-shrink: 0;
            width: 60px;
            color: #9ca3af;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .help-tooltip-value {
            flex: 1;
            color: #f3f4f6;
        }

        .help-tooltip-desc {
            color: #e5e7eb;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #374151;
        }

        .help-tooltip-example {
            background: #374151;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            color: #fbbf24;
        }

        /* Hoverable elements with help */
        .has-help {
            cursor: help;
            position: relative;
        }

        .has-help::after {
            content: '?';
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            margin-left: 4px;
            background: #e5e7eb;
            color: #6b7280;
            border-radius: 50%;
            font-size: 0.65rem;
            font-weight: 600;
            vertical-align: middle;
        }

        .tree-content .has-help::after {
            display: none;
        }

        .tree-content:hover .has-help::after {
            display: inline-flex;
        }

        /* Validation Error Styles */
        .validation-error {
            color: #dc2626 !important;
        }

        .validation-error::before {
            content: '⚠';
            margin-right: 4px;
            font-size: 0.85em;
        }

        .tree-content .validation-error::before {
            display: none;
        }

        .tree-content:hover .validation-error::before {
            display: inline;
        }

        td.attr-name.validation-error {
            color: #dc2626 !important;
        }

        td.attr-value.validation-error {
            background-color: var(--error-bg);
            color: var(--error-text);
            border-left: 3px solid var(--error-border);
        }

        /* ==================== */
        /* Mobile-only Elements (Hidden on Desktop by default) */
        /* ==================== */
        .mobile-hamburger,
        .mobile-menu,
        .mobile-detail-overlay,
        .mobile-detail-handle,
        .mobile-detail-close,
        .mobile-chips {
            display: none;
        }
        
        /* Desktop: Show radio buttons */
        .tree-scope-group:not(.mobile-chips),
        .search-scope:not(.mobile-chips) {
            display: flex;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                font-size: 15px;
            }
            
            main {
                flex-direction: column;
            }
            
            /* ==================== */
            /* Header Optimizations */
            /* ==================== */
            header {
                padding: 0.5rem 0.75rem;
                flex-wrap: nowrap;
                height: auto;
                min-height: 56px;
                gap: 0.5rem;
            }
            
            h1 {
                font-size: 1rem;
                white-space: nowrap;
                flex-shrink: 0;
                display: flex;
                align-items: center;
            }
            
            /* Hide title text on mobile, show only icon */
            h1 .app-title {
                display: none;
            }
            
            h1 .material-symbols-outlined {
                margin-right: 0;
                font-size: 1.4rem;
            }
            
            #drop-zone {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
                min-width: 80px;
                flex: 1;
                max-width: none;
            }
            
            #drop-zone .material-symbols-outlined {
                font-size: 1rem;
                flex-shrink: 0;
            }
            
            #drop-zone-text {
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                min-width: 0;
            }
            
            .help-upload-wrapper {
                display: none;
            }
            
            .mobile-help-upload {
                display: flex !important;
            }
            
            .header-controls {
                display: none;
            }
            
            .mobile-hamburger {
                display: flex !important;
                width: 44px;
                height: 44px;
                min-width: 44px;
                align-items: center;
                justify-content: center;
                border: 1px solid var(--border-color);
                border-radius: 0.5rem;
                background: var(--panel-bg);
                cursor: pointer;
                color: var(--text-color);
                transition: all 0.2s ease;
            }
            
            .mobile-hamburger:hover {
                border-color: var(--primary-color);
                color: var(--primary-color);
                background-color: var(--hover-color);
            }
            
            /* ==================== */
            /* Mobile Side Menu */
            /* ==================== */
            .mobile-menu {
                display: none;
                position: fixed;
                top: 0;
                right: 0;
                width: 100%;
                height: 100%;
                z-index: 10001;
            }
            
            .mobile-menu.visible {
                display: block;
            }
            
            .mobile-menu-overlay {
                position: absolute;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(2px);
            }
            
            .mobile-menu-content {
                position: absolute;
                right: 0;
                top: 0;
                width: 280px;
                max-width: 80vw;
                height: 100%;
                background: var(--panel-bg);
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
                transform: translateX(100%);
                transition: transform 0.3s ease;
                overflow-y: auto;
            }
            
            .mobile-menu.visible .mobile-menu-content {
                transform: translateX(0);
            }
            
            .mobile-menu-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 1rem;
                border-bottom: 1px solid var(--border-color);
                position: sticky;
                top: 0;
                background: var(--panel-bg);
                z-index: 1;
            }
            
            .mobile-menu-header h3 {
                margin: 0;
                font-size: 1.2rem;
                color: var(--primary-color);
            }
            
            .mobile-menu-close {
                width: 40px;
                height: 40px;
                border: none;
                background: var(--hover-color);
                border-radius: 50%;
                font-size: 1.5rem;
                color: var(--text-color);
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
            }
            
            .mobile-menu-close:hover {
                background: var(--primary-color);
                color: white;
            }
            
            .mobile-menu-body {
                padding: 0.5rem 0;
            }
            
            .mobile-menu-item-wrapper {
                padding: 0.5rem 1rem;
            }
            
            .mobile-menu-item {
                width: 100%;
                display: flex;
                align-items: center;
                gap: 1rem;
                padding: 1rem;
                border: none;
                background: transparent;
                color: var(--text-color);
                font-size: 1rem;
                text-align: left;
                cursor: pointer;
                transition: background 0.2s;
                min-height: 56px;
            }
            
            .mobile-menu-item:hover {
                background: var(--hover-color);
            }
            
            .mobile-menu-item .material-symbols-outlined {
                font-size: 1.5rem;
                color: var(--primary-color);
            }
            
            .mobile-help-upload .help-upload-btn {
                width: 100%;
                max-width: none;
                justify-content: flex-start;
                min-height: 56px;
            }
            
            /* ==================== */
            /* Tree & Detail Layout */
            /* ==================== */
            #tree-panel {
                width: 100%;
                height: 100%;
                border-right: none;
            }
            
            #detail-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 70vh;
                max-height: 70vh;
                background: var(--panel-bg);
                border-radius: 16px 16px 0 0;
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
                transform: translateY(100%);
                transition: transform 0.3s ease;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                padding: 0;
            }
            
            #detail-panel.visible {
                transform: translateY(0);
            }
            
            #detail-panel .search-filter-bar {
                flex-shrink: 0;
            }
            
            #detail-panel .detail-content {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .mobile-detail-overlay {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.3);
                z-index: 999;
                opacity: 0;
                pointer-events: none;
            }
            
            .mobile-detail-overlay.visible {
                opacity: 1;
                pointer-events: auto;
            }
            
            .mobile-detail-handle {
                display: block;
                width: 40px;
                height: 4px;
                background: var(--border-color);
                border-radius: 2px;
                margin: 8px auto;
                flex-shrink: 0;
            }
            
            .mobile-detail-close {
                display: flex;
                align-items: center;
                justify-content: center;
                position: absolute;
                top: 12px;
                right: 12px;
                width: 40px;
                height: 40px;
                border: none;
                background: var(--hover-color);
                border-radius: 50%;
                cursor: pointer;
                z-index: 10;
                transition: all 0.2s;
            }
            
            .mobile-detail-close .material-symbols-outlined {
                font-size: 1.5rem;
                color: var(--text-color);
            }
            
            .mobile-detail-close:hover {
                background: var(--primary-color);
            }
            
            .mobile-detail-close:hover .material-symbols-outlined {
                color: white;
            }
            
            /* ==================== */
            /* Chip Buttons */
            /* ==================== */
            .tree-scope-group:not(.mobile-chips),
            .search-scope:not(.mobile-chips) {
                display: none !important;
            }
            
            .mobile-chips {
                display: flex !important;
                gap: 0.5rem;
                flex-wrap: wrap;
            }
            
            .chip-btn {
                padding: 0.5rem 1rem;
                border: 1px solid var(--border-color);
                border-radius: 16px;
                background: var(--panel-bg);
                color: var(--text-color);
                font-size: 0.8rem;
                white-space: nowrap;
                cursor: pointer;
                transition: all 0.2s;
                min-height: 36px;
            }
            
            .chip-btn.active {
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }
            
            .chip-btn:hover:not(.active) {
                border-color: var(--primary-color);
                background: var(--hover-color);
            }
            
            /* ==================== */
            /* Touch Target Optimization */
            /* ==================== */
            .tree-content {
                padding: 12px 8px;
                min-height: 44px;
            }
            
            .header-btn,
            .tree-sort-btn,
            .xml-toolbar-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 0.6rem;
            }
            
            td, th {
                padding: 1.2rem 1rem;
                font-size: 0.9rem;
            }
            
            input[type="text"] {
                height: 44px;
                font-size: 16px; /* Prevent iOS zoom */
                padding: 0.6rem 1rem;
            }
            
            .tree-search-wrapper input {
                height: 44px;
                font-size: 16px;
            }
            
            .view-tab {
                flex: 1;
                justify-content: center;
                padding: 1rem 0.5rem;
                min-height: 50px;
            }
            
            /* ==================== */
            /* View Tabs */
            /* ==================== */
            .view-tabs {
                padding: 0;
                justify-content: space-around;
            }
            
            .view-tab span:not(.material-symbols-outlined) {
                display: none;
            }
            
            /* ==================== */
            /* Search Controls */
            /* ==================== */
            .search-controls {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .search-input-wrapper {
                width: 100%;
                min-width: auto;
            }
            
            .search-scope {
                width: 100%;
                justify-content: flex-start;
                flex-wrap: wrap;
            }
            
            /* ==================== */
            /* Tree Controls */
            /* ==================== */
            .tree-options {
                flex-direction: column;
                gap: 0.75rem;
                align-items: stretch;
            }
            
            .tree-scope-group {
                flex-wrap: wrap;
            }
            
            .tree-sort-btn {
                width: 100%;
                justify-content: center;
            }
            
            /* ==================== */
            /* Modal */
            /* ==================== */
            .modal-content {
                width: 95%;
                max-width: 95vw;
                max-height: 90vh;
            }
            
            .modal-body {
                padding: 1rem;
            }
            
            /* ==================== */
            /* XML View */
            /* ==================== */
            .xml-toolbar {
                padding: 0.5rem 0.75rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .xml-toolbar-btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
                min-width: auto;
                min-height: 36px;
            }
            
            .xml-info {
                font-size: 0.7rem;
            }
            
            .xml-content {
                margin: 0 0.25rem;
                padding: 0;
            }
            
            .xml-content pre {
                padding: 0.5rem;
                font-size: 0.75rem;
            }
            
            /* Monaco Editor mobile optimization */
            .cm-editor {
                font-size: 0.75rem;
            }
            
            .cm-content {
                padding: 0.5rem 0;
            }
            
            .cm-line {
                padding: 0 0.25rem;
            }
            
            /* ==================== */
            /* Detail Content Scrolling */
            /* ==================== */
            .detail-content {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            #tree-view-container {
                flex-direction: column;
            }
        }

        /* ==================== */
        /* Modal Styles         */
        /* ==================== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
        }

        .modal.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }

        .modal-content {
            position: relative;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--panel-bg);
        }

        .modal-header h2 {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-color);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
            line-height: 1;
        }

        .modal-close:hover {
            background: var(--hover-color);
            color: var(--primary-color);
        }

        .modal-body {
            padding: 2rem;
            overflow-y: auto;
            color: var(--text-color);
            line-height: 1.6;
        }

        .modal-body h3 {
            color: var(--primary-color);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body ul {
            margin: 0.5rem 0 1rem 1.5rem;
            padding: 0;
        }

        .modal-body li {
            margin-bottom: 0.5rem;
        }

        .modal-body p {
            margin-bottom: 0.75rem;
        }

        .modal-body a {
            color: var(--primary-color);
            text-decoration: none;
            transition: opacity 0.2s;
        }

        .modal-body a:hover {
            opacity: 0.8;
            text-decoration: underline;
        }

        .author-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--bg-color);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .author-info strong {
            color: var(--text-color);
        }

        /* ==================== */
        /* View Tabs Styles     */
        /* ==================== */
        .view-tabs {
            display: flex;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0 2rem;
            gap: 0;
            flex-shrink: 0;
        }

        .view-tab {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--secondary-text);
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            margin-bottom: -1px;
        }

        .view-tab:hover {
            color: var(--primary-color);
            background-color: var(--hover-color);
        }

        .view-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background-color: transparent;
        }

        /* View Container */
        .view-container {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .view-container.active {
            display: flex;
        }

        /* Tree View Container (inherits existing main flex layout) */
        #tree-view-container {
            flex-direction: row;
            width: 100%;
            height: 100%;
        }

        /* ==================== */
        /* XML View Styles      */
        /* ==================== */
        #xml-view-container {
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .xml-toolbar {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .xml-toolbar-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--panel-bg);
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-color);
            transition: all 0.15s;
        }

        .xml-toolbar-btn:hover {
            background-color: var(--hover-color);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .xml-toolbar-btn .btn-icon {
            font-size: 0.75rem;
        }

        .xml-info {
            margin-left: auto;
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .xml-content {
            flex: 1;
            overflow: hidden;
            margin: 0 1rem;
            background: var(--panel-bg);
            padding: 1rem 1.5rem;
            position: relative;
        }

        .xml-content pre {
            padding: 1.5rem;
            font-family: 'Consolas', 'Monaco', 'Fira Code', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            min-height: 100%;
            background: transparent !important;
        }

        .xml-content code {
            font-family: inherit;
            background: transparent !important;
        }

        /* CodeMirror 6 Styling */
        .cm-editor {
            height: 100%;
            font-family: 'Consolas', 'Monaco', 'Fira Code', monospace;
            font-size: 0.875rem;
        }

        .cm-scroller {
            overflow: auto;
        }

        .cm-content {
            padding: 1rem 0;
        }

        .cm-line {
            padding: 0 0.5rem;
        }

        /* XML Folding */
        .xml-fold-wrapper {
            position: relative;
        }

        .xml-fold-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            margin-right: 4px;
            background: #4b5563;
            color: #e5e7eb;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.65rem;
            font-family: monospace;
            line-height: 1;
            vertical-align: middle;
            transition: all 0.15s;
        }

        .xml-fold-btn:hover {
            background: var(--primary-color);
            color: white;
        }

        .xml-fold-content {
            display: inline;
        }

        .xml-fold-content.collapsed {
            display: none;
        }

        .xml-fold-placeholder {
            display: none;
            color: #9ca3af;
            font-style: italic;
        }

        .xml-fold-content.collapsed + .xml-fold-placeholder {
            display: inline;
        }

        /* XML Empty State */
        .xml-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--secondary-text);
            text-align: center;
            background: var(--bg-color);
        }

        .xml-empty-state svg {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive for View Tabs */
        @media (max-width: 768px) {
            .view-tabs {
                padding: 0 1rem;
            }
            
            .view-tab {
                padding: 0.75rem 1rem;
                font-size: 0.85rem;
            }
            
            .view-tab span:not(.material-symbols-outlined) {
                display: none;
            }
            
            #tree-view-container {
                flex-direction: column;
            }
            
            .xml-toolbar {
                padding: 0.5rem 1rem;
                flex-wrap: wrap;
            }
            
            .xml-content pre {
                padding: 1rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>

<header>
    <h1><span class="material-symbols-outlined">code</span><span class="app-title">XML Navigator</span></h1>
    <div id="drop-zone">
        <span class="material-symbols-outlined">upload_file</span>
        <span id="drop-zone-text">DRAG & DROP XML FILE HERE OR CLICK TO UPLOAD</span>
    </div>
    <input type="file" id="file-input" accept=".xml" style="display: none;">
    <div class="help-upload-wrapper" id="help-drop-zone">
        <button id="help-upload-btn" class="help-upload-btn">
            <span class="material-symbols-outlined">schema</span>
            <span id="help-status-text">加载帮助配置</span>
        </button>
        <input type="file" id="help-file-input" accept=".json" style="display: none;">
    </div>
    <div class="header-controls">
        <button id="reset-btn" class="header-btn">
            <span class="material-symbols-outlined">refresh</span>
            <span data-i18n="reset">重置</span>
        </button>
        <button id="help-btn" class="header-btn">
            <span class="material-symbols-outlined">help</span>
            <span data-i18n="help">帮助</span>
        </button>
        <button id="theme-toggle-btn" class="header-btn">
            <span class="material-symbols-outlined" id="theme-icon">dark_mode</span>
            <span data-i18n="theme">主题</span>
        </button>
        <button id="lang-toggle-btn" class="header-btn">
            <span class="material-symbols-outlined">language</span>
            <span data-i18n="language">语言</span>
        </button>
    </div>
    <!-- Mobile Hamburger Menu Button -->
    <button id="mobile-hamburger-btn" class="mobile-hamburger" style="display: none;">
        <span class="material-symbols-outlined">menu</span>
    </button>
</header>

<!-- Mobile Side Menu -->
<div id="mobile-menu" class="mobile-menu">
    <div class="mobile-menu-overlay"></div>
    <div class="mobile-menu-content">
        <div class="mobile-menu-header">
            <h3 data-i18n="menu">菜单</h3>
            <button class="mobile-menu-close">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        <div class="mobile-menu-body">
            <!-- Help Schema Upload -->
            <div class="mobile-menu-item-wrapper">
                <div class="help-upload-wrapper mobile-help-upload" id="mobile-help-drop-zone">
                    <button id="mobile-help-upload-btn" class="help-upload-btn">
                        <span class="material-symbols-outlined">schema</span>
                        <span id="mobile-help-status-text">加载帮助配置</span>
                    </button>
                </div>
            </div>
            <!-- Theme Toggle -->
            <button id="mobile-theme-toggle-btn" class="mobile-menu-item">
                <span class="material-symbols-outlined" id="mobile-theme-icon">dark_mode</span>
                <span data-i18n="theme">主题</span>
            </button>
            <!-- Language Toggle -->
            <button id="mobile-lang-toggle-btn" class="mobile-menu-item">
                <span class="material-symbols-outlined">language</span>
                <span data-i18n="language">语言</span>
            </button>
            <!-- Help -->
            <button id="mobile-help-btn" class="mobile-menu-item">
                <span class="material-symbols-outlined">help</span>
                <span data-i18n="help">帮助</span>
            </button>
            <!-- Reset -->
            <button id="mobile-reset-btn" class="mobile-menu-item">
                <span class="material-symbols-outlined">refresh</span>
                <span data-i18n="reset">重置</span>
            </button>
        </div>
    </div>
</div>

<!-- View Tabs -->
<div class="view-tabs">
    <button class="view-tab active" data-view="tree">
        <span class="material-symbols-outlined">account_tree</span>
        <span data-i18n="treeView">树形视图</span>
    </button>
    <button class="view-tab" data-view="xml">
        <span class="material-symbols-outlined">code</span>
        <span data-i18n="xmlView">XML 视图</span>
    </button>
</div>

<!-- Help Tooltip Element (also shows validation errors) -->
<div id="help-tooltip" class="help-tooltip"></div>

<!-- Help Modal -->
<div id="help-modal" class="modal">
    <div class="modal-overlay"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>XML Navigator</h2>
            <button class="modal-close" id="help-modal-close">✕</button>
        </div>
        <div class="modal-body" id="help-modal-body">
            <h3 data-i18n="aboutApp">关于 XML Navigator</h3>
            <p data-i18n="appDescription">一个现代化的 XML 文件浏览器和编辑器，支持树形视图、语法高亮和帮助配置验证。</p>
            
            <h3 data-i18n="features">功能特性</h3>
            <ul>
                <li data-i18n="feature1">树形视图：以层级结构浏览 XML 文档，支持展开/折叠</li>
                <li data-i18n="feature2">详情面板：查看节点属性和子元素的值</li>
                <li data-i18n="feature3">搜索与过滤：快速定位特定的节点或属性</li>
                <li data-i18n="feature8">节点搜索：按名称、值或两者搜索节点</li>
                <li data-i18n="feature9">排序功能：支持自然顺序、升序、降序排列</li>
                <li data-i18n="feature10">批量操作：一键展开或折叠所有节点</li>
                <li data-i18n="feature7">XML 视图：使用 Monaco 编辑器查看原始 XML</li>
                <li data-i18n="feature4">帮助配置：上传 JSON 配置文件进行字段验证</li>
                <li data-i18n="feature5">主题切换：支持浅色和深色模式</li>
                <li data-i18n="feature6">语言切换：支持中文和英文界面</li>
                <li data-i18n="feature11">状态持久化：自动保存和恢复应用状态</li>
                <li data-i18n="feature12">父路径高亮：选中节点时高亮显示父级路径</li>
            </ul>
            
            <h3 data-i18n="quickStart">快速开始</h3>
            <ul>
                <li data-i18n="step1">1. 上传 XML 文件（拖放或点击上传区域）</li>
                <li data-i18n="step2">2. 在树形视图中浏览 XML 结构</li>
                <li data-i18n="step3">3. 点击节点查看详细属性</li>
                <li data-i18n="step4">4. 使用搜索框快速定位内容</li>
                <li data-i18n="step5">5. 可选：加载帮助配置文件进行验证</li>
            </ul>
            
            <h3 data-i18n="treeViewControls">树视图控制</h3>
            <ul>
                <li data-i18n="searchBox">搜索框：搜索节点名称或值</li>
                <li data-i18n="searchScope">搜索范围：名称/值/全部</li>
                <li data-i18n="sortButton">排序按钮：切换排序方式</li>
                <li data-i18n="expandButton">展开/折叠按钮：批量操作所有节点</li>
            </ul>
            
            <h3 data-i18n="detailControls">详情面板控制</h3>
            <ul>
                <li data-i18n="filterAttrs">搜索框：过滤属性和值</li>
                <li data-i18n="filterScope">搜索范围：仅属性/仅值/全部</li>
                <li data-i18n="sortHeader">点击表头：排序属性列表</li>
            </ul>
            
            <h3 data-i18n="xmlViewControls">XML 视图控制</h3>
            <ul>
                <li data-i18n="foldButtons">折叠/展开按钮：控制代码折叠</li>
                <li data-i18n="lineStats">行号统计：显示文件信息</li>
            </ul>
            
            <h3 data-i18n="helpSchema">帮助配置格式</h3>
            <p data-i18n="schemaDesc">JSON 格式，支持字段验证、类型检查和提示信息。</p>
            <ul>
                <li data-i18n="schemaSupport">支持的字段：type, format, description, example, required</li>
                <li data-i18n="schemaTypes">支持的类型：string, integer, number, date, boolean</li>
            </ul>
            
            <h3 data-i18n="author">作者</h3>
            <div class="author-info">
                <span><strong data-i18n="authorInfo">Nick Jiang</strong></span>
                <span>-</span>
                <a href="mailto:congtao.jiang@outlook.com">congtao.jiang@outlook.com</a>
            </div>
        </div>
    </div>
</div>

<main>
    <!-- Mobile Detail Overlay -->
    <div id="mobile-detail-overlay" class="mobile-detail-overlay"></div>
    
    <!-- Tree View Container -->
    <div id="tree-view-container" class="view-container active">
    <div id="tree-panel">
        <!-- Tree Controls (hidden by default) -->
        <div class="tree-controls" id="tree-controls">
            <div class="tree-search-wrapper">
                <input 
                    type="text" 
                    id="tree-search-input" 
                    data-i18n="searchNodePlaceholder"
                    placeholder="搜索节点名称或值..."
                />
            </div>
            <div class="tree-options">
                <div class="tree-scope-group">
                    <label>
                        <input type="radio" name="tree-search-scope" value="name" />
                        <span data-i18n="searchName">名称</span>
                    </label>
                    <label>
                        <input type="radio" name="tree-search-scope" value="value" />
                        <span data-i18n="searchValue">值</span>
                    </label>
                    <label>
                        <input type="radio" name="tree-search-scope" value="both" checked />
                        <span data-i18n="searchBoth">全部</span>
                    </label>
                </div>
                <!-- Mobile Chip Buttons for Tree Search Scope -->
                <div class="tree-scope-group mobile-chips" style="display: none;">
                    <button class="chip-btn" data-scope="name">
                        <span data-i18n="searchName">名称</span>
                    </button>
                    <button class="chip-btn" data-scope="value">
                        <span data-i18n="searchValue">值</span>
                    </button>
                    <button class="chip-btn active" data-scope="both">
                        <span data-i18n="searchBoth">全部</span>
                    </button>
                </div>
                <button class="tree-sort-btn" id="tree-sort-btn">
                    <span class="tree-sort-icon" id="tree-sort-icon">↕</span>
                    <span data-i18n="sort">排序</span>
                </button>
                <button class="tree-sort-btn" id="tree-toggle-btn">
                    <span class="tree-sort-icon" id="tree-toggle-icon">⊞</span>
                    <span id="tree-toggle-text" data-i18n="expand">展开</span>
                </button>
            </div>
        </div>
        
        <!-- Tree Container -->
        <div class="tree-container" id="tree-container">
            <div class="empty-state" style="height: auto; padding-top: 2rem;">
                NO FILE LOADED.
            </div>
        </div>
    </div>
    
    <div id="detail-panel">
        <!-- Mobile Detail Controls -->
        <div class="mobile-detail-handle"></div>
        <button class="mobile-detail-close">
            <span class="material-symbols-outlined">close</span>
        </button>
        
        <!-- Search Filter Bar (hidden by default) -->
        <div class="search-filter-bar" id="search-bar">
            <div class="search-controls">
                <div class="search-input-wrapper">
                    <input 
                        type="text" 
                        id="search-input" 
                        data-i18n="searchPropertyPlaceholder"
                        placeholder="搜索 PROPERTY/TAG 或 VALUE..."
                    />
                </div>
                <div class="search-scope">
                    <label>
                        <input type="radio" name="search-scope" value="property" />
                        <span data-i18n="propertyTag">仅 PROPERTY/TAG</span>
                    </label>
                    <label>
                        <input type="radio" name="search-scope" value="value" />
                        <span data-i18n="valueOnly">仅 VALUE</span>
                    </label>
                    <label>
                        <input type="radio" name="search-scope" value="both" checked />
                        <span data-i18n="propertyOrValue">PROPERTY/TAG 或 VALUE</span>
                    </label>
                </div>
                <!-- Mobile Chip Buttons for Detail Search Scope -->
                <div class="search-scope mobile-chips" style="display: none;">
                    <button class="chip-btn" data-scope="property">
                        <span data-i18n="propertyTag">属性</span>
                    </button>
                    <button class="chip-btn" data-scope="value">
                        <span data-i18n="valueOnly">值</span>
                    </button>
                    <button class="chip-btn active" data-scope="both">
                        <span data-i18n="searchBoth">全部</span>
                    </button>
                </div>
            </div>
            <div class="search-info" id="search-info"></div>
        </div>
        
        <!-- Detail Content -->
        <div class="detail-content" id="detail-content">
            <div class="empty-state">
                <svg style="width: 48px; height: 48px; margin-bottom: 1rem; opacity: 0.5;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <p>SELECT A NODE FROM THE TREE TO VIEW DETAILS</p>
            </div>
        </div>
    </div>
    </div>
    <!-- End Tree View Container -->
    
    <!-- XML View Container -->
    <div id="xml-view-container" class="view-container">
        <div class="xml-toolbar">
            <button class="xml-toolbar-btn" id="xml-fold-all">
                <span class="btn-icon">▼</span>
                <span data-i18n="foldAll">折叠全部</span>
            </button>
            <button class="xml-toolbar-btn" id="xml-unfold-all">
                <span class="btn-icon">▶</span>
                <span data-i18n="unfoldAll">展开全部</span>
            </button>
            <span class="xml-info" id="xml-info"></span>
        </div>
        <div class="xml-content" id="xml-content">
            <div class="xml-empty-state">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <p>加载 XML 文件后在此查看原始内容</p>
            </div>
        </div>
    </div>
    <!-- End XML View Container -->
</main>
<script>
    // =============================================
    // Dynamic Monaco Loader - CDN fallback for browser, local for Tauri
    // =============================================
    function loadMonaco() {
        return new Promise((resolve, reject) => {
            // For Tauri, use local Monaco
            if (window.__TAURI__ !== undefined) {
                const script = document.createElement('script');
                script.src = 'monaco/vs/loader.js';
                script.onload = () => {
                    require.config({ paths: { 'vs': 'monaco/vs' }});
                    require(['vs/editor/editor.main'], function() {
                        window.monacoReady = true;
                        console.log('✅ Monaco Editor loaded (local)');
                        resolve();
                    });
                };
                script.onerror = () => reject(new Error('Failed to load local Monaco'));
                document.head.appendChild(script);
            } else {
                // For browser, use CDN
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js';
                script.onload = () => {
                    require.config({ 
                        paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' }
                    });
                    require(['vs/editor/editor.main'], function() {
                        window.monacoReady = true;
                        console.log('✅ Monaco Editor loaded (CDN)');
                        resolve();
                    });
                };
                script.onerror = () => reject(new Error('Failed to load Monaco from CDN'));
                document.head.appendChild(script);
            }
        });
    }
    
    // Monaco Editor 初始化
    window.monacoEditor = null;
    window.monacoReady = false;
    
    // Load Monaco dynamically based on environment
    loadMonaco().catch(err => {
        console.error('❌ Monaco Editor failed to load:', err);
        // App will show fallback message in XML view
    });

    // --- State & Elements ---
    const dropZone = document.getElementById('drop-zone');
    const dropZoneText = document.getElementById('drop-zone-text');
    const fileInput = document.getElementById('file-input');
    const treePanel = document.getElementById('tree-panel');
    const treeContainer = document.getElementById('tree-container');
    const treeControls = document.getElementById('tree-controls');
    const treeSearchInput = document.getElementById('tree-search-input');
    const treeSortBtn = document.getElementById('tree-sort-btn');
    const treeSortIcon = document.getElementById('tree-sort-icon');
    const treeToggleBtn = document.getElementById('tree-toggle-btn');
    const treeToggleIcon = document.getElementById('tree-toggle-icon');
    const treeToggleText = document.getElementById('tree-toggle-text');
    const detailPanel = document.getElementById('detail-panel');
    const detailContent = document.getElementById('detail-content');
    const searchBar = document.getElementById('search-bar');
    const searchInput = document.getElementById('search-input');
    const searchInfo = document.getElementById('search-info');
    
    // Help schema elements
    const helpUploadBtn = document.getElementById('help-upload-btn');
    const helpFileInput = document.getElementById('help-file-input');
    const helpStatusText = document.getElementById('help-status-text');
    const helpTooltip = document.getElementById('help-tooltip');
    
    // New UI elements
    const helpModal = document.getElementById('help-modal');
    const helpModalClose = document.getElementById('help-modal-close');
    const resetBtn = document.getElementById('reset-btn');
    const helpBtn = document.getElementById('help-btn');
    const themeToggleBtn = document.getElementById('theme-toggle-btn');
    const langToggleBtn = document.getElementById('lang-toggle-btn');
    
    var xmlDoc = null;
    var xmlRawContent = null; // Store raw XML string for localStorage persistence
    var xmlFilename = null; // Store filename for display after restore
    var currentNode = null;
    var currentNodePath = null; // Store path for re-selection
    var sortState = 'natural'; // 'natural', 'asc', 'desc' (for detail panel)
    var searchText = ''; // 搜索文本 (for detail panel)
    var searchScope = 'both'; // 'property', 'value', 'both' (for detail panel)
    // Tree panel states
    var treeSearchText = '';
    var treeSearchScope = 'both'; // 'name', 'value', 'both'
    var treeSortState = 'natural'; // 'natural', 'asc', 'desc'
    var treeExpanded = false; // false = collapsed, true = expanded
    
    // Help schema state
    var helpSchema = null; // Parsed help schema
    var helpSchemaRaw = null; // Raw JSON string for persistence
    var helpSchemaFilename = null; // Help schema filename
    
    // View state
    var currentView = 'tree'; // 'tree' | 'xml'
    var xmlViewRendered = false; // Track if XML view needs re-render
    
    // Help drop zone element
    const helpDropZone = document.getElementById('help-drop-zone');
    
    // View elements
    const viewTabs = document.querySelectorAll('.view-tab');
    const treeViewContainer = document.getElementById('tree-view-container');
    const xmlViewContainer = document.getElementById('xml-view-container');
    const xmlContentEl = document.getElementById('xml-content');
    const xmlInfoEl = document.getElementById('xml-info');

    // --- Theme & Language State ---
    var currentTheme = 'light'; // 'light' | 'dark'
    var currentLang = 'zh'; // 'zh' | 'en'
    
    // --- Translations Dictionary ---
    const translations = {
        zh: {
            // Application Name (don't translate)
            appName: 'XML Navigator',
            
            // Header
            dropZoneText: '拖放 XML 文件到这里或点击上传',
            dropZoneTextTauri: '点击打开 XML 文件或拖放文件',
            loadHelpConfig: '加载模式',
            reset: '重置',
            help: '帮助',
            theme: '主题',
            language: '中',
            
            // View Tabs
            treeView: '树形视图',
            xmlView: 'XML 视图',
            
            // Tree Controls
            searchNodePlaceholder: '搜索节点名称或值...',
            searchName: '名称',
            searchValue: '值',
            searchBoth: '全部',
            sort: '排序',
            expand: '展开',
            collapse: '折叠',
            
            // Detail Panel
            searchPropertyPlaceholder: '搜索 PROPERTY/TAG 或 VALUE...',
            propertyTag: '仅 PROPERTY/TAG',
            valueOnly: '仅 VALUE',
            propertyOrValue: 'PROPERTY/TAG 或 VALUE',
            propertyTagHeader: 'PROPERTY / TAG',
            valueHeader: 'VALUE',
            
            // XML View
            foldAll: '折叠全部',
            unfoldAll: '展开全部',
            xmlEmptyState: '加载 XML 文件后在此查看原始内容',
            loadingEditor: '正在加载代码编辑器...',
            editorInitFailed: '初始化编辑器失败',
            checkConsole: '请检查浏览器控制台了解详情',
            lines: '行',
            
            // Empty States
            noFileLoaded: '未加载文件。',
            selectNode: '从树中选择一个节点以查看详情',
            noMatchingNodes: '未找到匹配的节点。',
            noAttributesOrChildren: '没有直接属性或叶子节点的值。',
            noMatchingResults: '没有匹配的结果',
            
            // Search Info
            showingResults: '显示',
            of: '/',
            items: '项',
            
            // Validation Errors
            requiredField: '此字段为必填项',
            formatMismatch: '格式不匹配，期望格式',
            typeError: '类型错误',
            expectInteger: '期望整数，实际值',
            expectNumber: '期望数字，实际值',
            expectBoolean: '期望布尔值，实际值',
            dateFormatError: '日期格式错误',
            unrecognizedDateFormat: '无法识别的日期格式',
            expectFormat: '期望',
            actualValue: '实际值',
            validationErrors: '验证错误',
            
            // Tooltip Labels
            type: '类型',
            format: '格式',
            example: '示例',
            required: '必填',
            yes: '是',
            no: '否',
            description: '描述',
            
            // Messages
            invalidXmlFile: '请上传有效的 XML 文件。',
            xmlParseError: 'XML 解析错误',
            invalidXmlStructure: '无效的 XML 文档结构',
            treeRenderError: '树渲染错误',
            detailResetError: '重置详情面板错误',
            fileReadError: '读取文件错误。',
            invalidHelpFormat: '帮助配置文件格式无效：缺少 definitions 或 paths',
            helpParseError: '帮助配置文件解析错误',
            readHelpError: '读取帮助配置文件失败',
            uploadJsonFile: '请上传 JSON 格式的帮助配置文件',
            
            // Tauri Messages
            openFileFailed: '打开文件失败',
            openHelpFileFailed: '打开帮助配置文件失败',
            readFileFailed: '读取拖放文件失败',
            dragXmlFile: '请拖放 XML 格式的文件',
            dragJsonFile: '请上传 JSON 格式的帮助配置文件',
            noContentToSave: '没有可保存的内容',
            fileSaved: '文件已保存',
            saveFileFailed: '保存文件失败',
            updateAvailable: '发现新版本',
            updateNow: '是否现在更新？',
            alreadyLatest: '当前已是最新版本',
            updateNotConfigured: '更新功能未配置',
            checkUpdateFailed: '检查更新失败',
            
            // Help Modal
            helpTitle: '帮助',
            aboutApp: '关于 XML Navigator',
            appDescription: '一个现代化的 XML 文件浏览器和编辑器，支持树形视图、语法高亮和帮助配置验证。',
            features: '功能特性',
            feature1: '树形视图：以层级结构浏览 XML 文档，支持展开/折叠',
            feature2: '详情面板：查看节点属性和子元素的值',
            feature3: '搜索与过滤：快速定位特定的节点或属性',
            feature4: '帮助配置：上传 JSON 配置文件进行字段验证',
            feature5: '主题切换：支持浅色和深色模式',
            feature6: '语言切换：支持中文和英文界面',
            feature7: 'XML 视图：使用 Monaco 编辑器查看原始 XML',
            feature8: '节点搜索：按名称、值或两者搜索节点',
            feature9: '排序功能：支持自然顺序、升序、降序排列',
            feature10: '批量操作：一键展开或折叠所有节点',
            feature11: '状态持久化：自动保存和恢复应用状态',
            feature12: '父路径高亮：选中节点时高亮显示父级路径',
            quickStart: '快速开始',
            step1: '1. 上传 XML 文件（拖放或点击上传区域）',
            step2: '2. 在树形视图中浏览 XML 结构',
            step3: '3. 点击节点查看详细属性',
            step4: '4. 使用搜索框快速定位内容',
            step5: '5. 可选：加载帮助配置文件进行验证',
            treeViewControls: '树视图控制',
            searchBox: '搜索框：搜索节点名称或值',
            searchScope: '搜索范围：名称/值/全部',
            sortButton: '排序按钮：切换排序方式',
            expandButton: '展开/折叠按钮：批量操作所有节点',
            detailControls: '详情面板控制',
            filterAttrs: '搜索框：过滤属性和值',
            filterScope: '搜索范围：仅属性/仅值/全部',
            sortHeader: '点击表头：排序属性列表',
            xmlViewControls: 'XML 视图控制',
            foldButtons: '折叠/展开按钮：控制代码折叠',
            lineStats: '行号统计：显示文件信息',
            usage: '使用方法',
            usage1: '点击或拖放上传 XML 文件',
            usage2: '在树形视图中点击节点查看详情',
            usage3: '使用搜索框过滤节点或属性',
            usage4: '可选：上传帮助配置文件启用字段验证',
            usage5: '切换主题和语言以获得更好的体验',
            helpSchema: '帮助配置格式',
            schemaDesc: 'JSON 格式，支持字段验证、类型检查和提示信息。',
            schemaSupport: '支持的字段：type, format, description, example, required',
            schemaTypes: '支持的类型：string, integer, number, date, boolean',
            author: '作者',
            authorInfo: 'Nick Jiang',
            close: '关闭',
            
            // Reset Confirmation
            resetConfirmTitle: '确认重置',
            resetConfirmMsg: '确定要重置吗？这将清除已加载的 XML 文件和帮助配置，但会保留您的主题和语言设置。',
            confirm: '确认',
            cancel: '取消'
        },
        en: {
            // Application Name (don't translate)
            appName: 'XML Navigator',
            
            // Header
            dropZoneText: 'Drag & drop XML file here or click to upload',
            dropZoneTextTauri: 'Click to open XML file or drag & drop',
            loadHelpConfig: 'Load Schema',
            reset: 'Reset',
            help: 'Help',
            theme: 'Theme',
            language: 'En',
            
            // View Tabs
            treeView: 'Tree View',
            xmlView: 'XML View',
            
            // Tree Controls
            searchNodePlaceholder: 'Search node name or value...',
            searchName: 'Name',
            searchValue: 'Value',
            searchBoth: 'Both',
            sort: 'Sort',
            expand: 'Expand',
            collapse: 'Collapse',
            
            // Detail Panel
            searchPropertyPlaceholder: 'Search PROPERTY/TAG or VALUE...',
            propertyTag: 'Property/Tag Only',
            valueOnly: 'Value Only',
            propertyOrValue: 'Property/Tag or Value',
            propertyTagHeader: 'PROPERTY / TAG',
            valueHeader: 'VALUE',
            
            // XML View
            foldAll: 'Fold All',
            unfoldAll: 'Unfold All',
            xmlEmptyState: 'Load an XML file to view raw content here',
            loadingEditor: 'Loading code editor...',
            editorInitFailed: 'Failed to initialize editor',
            checkConsole: 'Check browser console for details',
            lines: 'lines',
            
            // Empty States
            noFileLoaded: 'No file loaded.',
            selectNode: 'Select a node from the tree to view details',
            noMatchingNodes: 'No matching nodes found.',
            noAttributesOrChildren: 'No direct attributes or leaf children values.',
            noMatchingResults: 'No matching results',
            
            // Search Info
            showingResults: 'Showing',
            of: '/',
            items: 'items',
            
            // Validation Errors
            requiredField: 'This field is required',
            formatMismatch: 'Format mismatch, expected format',
            typeError: 'Type error',
            expectInteger: 'Expected integer, actual value',
            expectNumber: 'Expected number, actual value',
            expectBoolean: 'Expected boolean, actual value',
            dateFormatError: 'Date format error',
            unrecognizedDateFormat: 'Unrecognized date format',
            expectFormat: 'Expected',
            actualValue: 'actual value',
            validationErrors: 'Validation Errors',
            
            // Tooltip Labels
            type: 'Type',
            format: 'Format',
            example: 'Example',
            required: 'Required',
            yes: 'Yes',
            no: 'No',
            description: 'Description',
            
            // Messages
            invalidXmlFile: 'Please upload a valid XML file.',
            xmlParseError: 'XML parse error',
            invalidXmlStructure: 'Invalid XML document structure',
            treeRenderError: 'Tree render error',
            detailResetError: 'Detail panel reset error',
            fileReadError: 'Error reading file.',
            invalidHelpFormat: 'Invalid help config format: missing definitions or paths',
            helpParseError: 'Help config parse error',
            readHelpError: 'Failed to read help config file',
            uploadJsonFile: 'Please upload a JSON format help config file',
            
            // Tauri Messages
            openFileFailed: 'Failed to open file',
            openHelpFileFailed: 'Failed to open help config file',
            readFileFailed: 'Failed to read dropped file',
            dragXmlFile: 'Please drag and drop an XML file',
            dragJsonFile: 'Please upload a JSON format help config file',
            noContentToSave: 'No content to save',
            fileSaved: 'File saved',
            saveFileFailed: 'Failed to save file',
            updateAvailable: 'New version available',
            updateNow: 'Update now?',
            alreadyLatest: 'Already on latest version',
            updateNotConfigured: 'Update feature not configured',
            checkUpdateFailed: 'Failed to check for updates',
            
            // Help Modal
            helpTitle: 'Help',
            aboutApp: 'About XML Navigator',
            appDescription: 'A modern XML file browser and editor with tree view, syntax highlighting, and schema validation.',
            features: 'Features',
            feature1: 'Tree View: Browse XML in hierarchical structure with expand/collapse',
            feature2: 'Detail Panel: View node attributes and child element values',
            feature3: 'Search & Filter: Quickly locate specific nodes or attributes',
            feature4: 'Help Config: Upload JSON config file for field validation',
            feature5: 'Theme Toggle: Support light and dark mode',
            feature6: 'Language Switch: Support Chinese and English interface',
            feature7: 'XML View: View raw XML with Monaco editor',
            feature8: 'Node Search: Search by name, value, or both',
            feature9: 'Sorting: Natural order, ascending, or descending',
            feature10: 'Batch Operations: Expand or collapse all nodes at once',
            feature11: 'State Persistence: Auto-save and restore application state',
            feature12: 'Parent Path Highlighting: Highlight parent path when node selected',
            quickStart: 'Quick Start',
            step1: '1. Upload XML file (drag & drop or click upload area)',
            step2: '2. Browse XML structure in tree view',
            step3: '3. Click node to view detailed attributes',
            step4: '4. Use search box to quickly locate content',
            step5: '5. Optional: Load help config file for validation',
            treeViewControls: 'Tree View Controls',
            searchBox: 'Search Box: Search node name or value',
            searchScope: 'Search Scope: Name / Value / Both',
            sortButton: 'Sort Button: Toggle sort order',
            expandButton: 'Expand/Collapse Button: Batch operation on all nodes',
            detailControls: 'Detail Panel Controls',
            filterAttrs: 'Search Box: Filter attributes and values',
            filterScope: 'Filter Scope: Property Only / Value Only / Both',
            sortHeader: 'Click Header: Sort attribute list',
            xmlViewControls: 'XML View Controls',
            foldButtons: 'Fold/Unfold Buttons: Control code folding',
            lineStats: 'Line Stats: Display file information',
            usage: 'Usage',
            usage1: 'Click or drag-drop to upload XML file',
            usage2: 'Click node in tree view to see details',
            usage3: 'Use search box to filter nodes or attributes',
            usage4: 'Optional: Upload help config file to enable field validation',
            usage5: 'Toggle theme and language for better experience',
            helpSchema: 'Help Schema Format',
            schemaDesc: 'JSON format with field validation, type checking and tooltips.',
            schemaSupport: 'Supported fields: type, format, description, example, required',
            schemaTypes: 'Supported types: string, integer, number, date, boolean',
            author: 'Author',
            authorInfo: 'Nick Jiang',
            close: 'Close',
            
            // Reset Confirmation
            resetConfirmTitle: 'Confirm Reset',
            resetConfirmMsg: 'Are you sure you want to reset? This will clear the loaded XML file and help config, but will keep your theme and language settings.',
            confirm: 'Confirm',
            cancel: 'Cancel'
        }
    };
    
    // Translation function
    function t(key) {
        return translations[currentLang]?.[key] || key;
    }
    
    // --- LocalStorage Keys ---
    const STORAGE_KEYS = {
        XML_CONTENT: 'xml_browser_xml_content',
        XML_FILENAME: 'xml_browser_xml_filename',
        TREE_SEARCH_TEXT: 'xml_browser_tree_search_text',
        TREE_SEARCH_SCOPE: 'xml_browser_tree_search_scope',
        TREE_SORT_STATE: 'xml_browser_tree_sort_state',
        TREE_EXPANDED: 'xml_browser_tree_expanded',
        SELECTED_NODE_PATH: 'xml_browser_selected_node_path',
        DETAIL_SEARCH_TEXT: 'xml_browser_detail_search_text',
        DETAIL_SEARCH_SCOPE: 'xml_browser_detail_search_scope',
        DETAIL_SORT_STATE: 'xml_browser_detail_sort_state',
        HELP_SCHEMA: 'xml_browser_help_schema',
        HELP_SCHEMA_FILENAME: 'xml_browser_help_schema_filename',
        CURRENT_VIEW: 'xml_browser_current_view',
        XML_FOLD_STATE: 'xml_browser_xml_fold_state',
        CURRENT_THEME: 'xml_browser_current_theme',
        CURRENT_LANG: 'xml_browser_current_lang'
    };

    // =============================================
    // Translation & Theme Functions
    // =============================================
    
    // Apply translations to all elements with data-i18n attribute
    function applyTranslations() {
        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            const translation = t(key);
            
            // Handle different element types
            if (el.tagName === 'INPUT' && el.type !== 'radio' && el.type !== 'checkbox') {
                el.placeholder = translation;
            } else {
                el.textContent = translation;
            }
        });
        
        // Update drop zone text
        if (isTauri) {
            dropZoneText.textContent = xmlFilename ? xmlFilename : t('dropZoneTextTauri');
        } else {
            dropZoneText.textContent = xmlFilename ? xmlFilename : t('dropZoneText');
        }
        
        // Update help upload button text if no file loaded
        if (!helpSchemaFilename) {
            helpStatusText.textContent = t('loadHelpConfig');
        }
        
        // Update tree view empty state (if no file loaded)
        if (!xmlDoc) {
            const treeEmptyState = treeContainer.querySelector('.empty-state');
            if (treeEmptyState) {
                treeEmptyState.textContent = t('noFileLoaded');
            }
        }
        
        // Update detail panel empty state (if no node selected)
        if (!currentNode) {
            const detailEmptyState = detailContent.querySelector('.empty-state p');
            if (detailEmptyState) {
                detailEmptyState.textContent = t('selectNode');
            }
        }
        
        // Re-render tree and details if XML is loaded
        if (xmlDoc) {
            renderTree(xmlDoc);
            if (currentNode) {
                showNodeDetails(currentNode);
            }
        }
        
        // Update XML view info
        if (xmlRawContent) {
            updateXmlInfo();
        }
    }
    
    // Set theme
    function setTheme(theme) {
        currentTheme = theme;
        document.documentElement.setAttribute('data-theme', theme);
        
        // Update Monaco editor theme if it exists
        if (window.monacoEditor && window.monacoReady) {
            const monacoTheme = theme === 'dark' ? 'vs-dark' : 'vs';
            monaco.editor.setTheme(monacoTheme);
        }
        
        // Update theme toggle icon
        const themeIcon = document.getElementById('theme-icon');
        if (themeIcon) {
            themeIcon.textContent = theme === 'dark' ? 'light_mode' : 'dark_mode';
        }
        
        saveStateToStorage();
    }
    
    // Toggle theme
    function toggleTheme() {
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
    }
    
    // Set language
    function setLanguage(lang) {
        currentLang = lang;
        applyTranslations();
        saveStateToStorage();
    }
    
    // Toggle language
    function toggleLanguage() {
        const newLang = currentLang === 'zh' ? 'en' : 'zh';
        setLanguage(newLang);
    }
    
    // Show help modal
    function showHelpModal() {
        helpModal.classList.add('visible');
    }
    
    // Hide help modal
    function hideHelpModal() {
        helpModal.classList.remove('visible');
    }
    
    // Reset application
    function resetApplication() {
        // Confirm with user
        const confirmMsg = t('resetConfirmMsg');
        const confirmed = confirm(confirmMsg);
        
        if (!confirmed) return;
        
        // Clear XML related data
        xmlDoc = null;
        xmlRawContent = null;
        xmlFilename = null;
        currentNode = null;
        currentNodePath = null;
        xmlViewRendered = false;
        
        // Clear help schema
        helpSchema = null;
        helpSchemaRaw = null;
        helpSchemaFilename = null;
        
        // Reset UI states
        if (isTauri) {
            dropZoneText.textContent = t('dropZoneTextTauri');
        } else {
            dropZoneText.textContent = t('dropZoneText');
        }
        helpUploadBtn.classList.remove('loaded');
        helpStatusText.textContent = t('loadHelpConfig');
        
        // Clear tree
        treeContainer.innerHTML = `<div class="empty-state" style="height: auto; padding-top: 2rem;">${escapeHtml(t('noFileLoaded'))}</div>`;
        treeControls.classList.remove('visible');
        
        // Reset detail view
        resetDetailView();
        
        // Clear XML view
        if (window.monacoEditor) {
            window.monacoEditor.setValue('');
        }
        xmlInfoEl.textContent = '';
        
        // Clear localStorage for XML and help schema
        localStorage.removeItem(STORAGE_KEYS.XML_CONTENT);
        localStorage.removeItem(STORAGE_KEYS.XML_FILENAME);
        localStorage.removeItem(STORAGE_KEYS.HELP_SCHEMA);
        localStorage.removeItem(STORAGE_KEYS.HELP_SCHEMA_FILENAME);
        localStorage.removeItem(STORAGE_KEYS.SELECTED_NODE_PATH);
        localStorage.removeItem(STORAGE_KEYS.TREE_SEARCH_TEXT);
        localStorage.removeItem(STORAGE_KEYS.TREE_SEARCH_SCOPE);
        localStorage.removeItem(STORAGE_KEYS.TREE_SORT_STATE);
        localStorage.removeItem(STORAGE_KEYS.TREE_EXPANDED);
        localStorage.removeItem(STORAGE_KEYS.DETAIL_SEARCH_TEXT);
        localStorage.removeItem(STORAGE_KEYS.DETAIL_SEARCH_SCOPE);
        localStorage.removeItem(STORAGE_KEYS.DETAIL_SORT_STATE);
        localStorage.removeItem(STORAGE_KEYS.CURRENT_VIEW);
        
        // Reset search and sort states
        treeSearchText = '';
        treeSearchInput.value = '';
        treeSearchScope = 'both';
        document.querySelector('input[name="tree-search-scope"][value="both"]').checked = true;
        treeSortState = 'natural';
        treeSortIcon.textContent = '↕';
        treeExpanded = false;
        treeToggleIcon.textContent = '⊞';
        treeToggleText.textContent = t('expand');
        
        searchText = '';
        searchInput.value = '';
        searchScope = 'both';
        document.querySelector('input[name="search-scope"][value="both"]').checked = true;
        sortState = 'natural';
        
        // Switch to tree view
        currentView = 'tree';
        viewTabs.forEach(tab => {
            tab.classList.toggle('active', tab.dataset.view === 'tree');
        });
        treeViewContainer.classList.add('active');
        xmlViewContainer.classList.remove('active');
        
        // Clear Tauri file paths
        if (isTauri) {
            currentFilePath = null;
            currentHelpFilePath = null;
        }
        
        console.log('✅ Application reset completed');
    }

    // =============================================
    // Environment Detection (must be before event listeners)
    // =============================================
    // Check if already initialized to avoid duplicate variable errors
    if (typeof window._xmlNavigatorInitialized === 'undefined') {
        window._xmlNavigatorInitialized = true;
    } else {
        console.warn('Script already initialized, skipping...');
        // Early return if needed, but continue for now
    }
    
    // Use var to avoid "duplicate variable that shadows global property" error
    var isTauri = window.__TAURI__ !== undefined;
    
    // Tauri v2 API - use core.invoke for plugin commands
    var tauriInvoke = null;
    var currentFilePath = null;
    var currentHelpFilePath = null;
    
    if (isTauri) {
        console.log('🖥️ Running in Tauri v2 desktop environment');
        console.log('Available __TAURI__ keys:', Object.keys(window.__TAURI__));
        console.log('__TAURI__ object:', window.__TAURI__);
        
        // Tauri v2: Try multiple ways to get invoke
        if (window.__TAURI__.core?.invoke) {
            tauriInvoke = window.__TAURI__.core.invoke;
            console.log('✅ Found invoke via core.invoke');
        } else if (window.__TAURI__.invoke) {
            tauriInvoke = window.__TAURI__.invoke;
            console.log('✅ Found invoke via __TAURI__.invoke');
        } else if (window.__TAURI__.dialog) {
            // If dialog plugin is directly available (withGlobalTauri)
            console.log('✅ Dialog plugin directly available');
            // We'll use invoke wrapper but note that dialog might be available
        }
        
        if (!tauriInvoke) {
            console.error('❌ Tauri invoke not found!');
            console.error('Available __TAURI__ keys:', Object.keys(window.__TAURI__));
            console.error('__TAURI__ structure:', JSON.stringify(Object.keys(window.__TAURI__ || {})));
        } else {
            console.log('✅ tauriInvoke function ready');
        }
    } else {
        console.log('🌐 Running in browser environment');
    }
    
    // =============================================
    // Tauri v2 Plugin Wrappers (using core.invoke)
    // =============================================
    
    // Dialog plugin wrapper - open file dialog
    async function tauriDialogOpen(options) {
        // First try direct plugin access (if withGlobalTauri is enabled)
        if (window.__TAURI__?.dialog?.open) {
            console.log('Using direct dialog.open API');
            try {
                const result = await window.__TAURI__.dialog.open(options);
                return result;
            } catch (err) {
                console.error('Direct dialog.open failed:', err);
            }
        }
        
        // Fallback to invoke
        if (!tauriInvoke) {
            console.error('tauriInvoke not available and dialog plugin not found');
            return null;
        }
        try {
            console.log('Calling dialog.open via invoke with options:', options);
            // Tauri v2: invoke format is 'plugin:name|command' with direct options
            const result = await tauriInvoke('plugin:dialog|open', options);
            console.log('Dialog open result:', result);
            return result;
        } catch (err) {
            console.error('Dialog open error:', err);
            // Try alternative format
            try {
                console.log('Trying alternative format with wrapped options...');
                const result = await tauriInvoke('plugin:dialog|open', { options });
                return result;
            } catch (err2) {
                console.error('Alternative format also failed:', err2);
                throw err;
            }
        }
    }
    
    // Dialog plugin wrapper - show message
    async function tauriDialogMessage(message, options = {}) {
        if (!tauriInvoke) return;
        try {
            await tauriInvoke('plugin:dialog|message', { 
                message, 
                title: options.title || 'Message',
                kind: options.kind || 'info'
            });
        } catch (err) {
            console.error('Dialog message error:', err);
            // Fallback to alert
            alert(message);
        }
    }
    
    // FS plugin wrapper - read text file
    async function tauriReadTextFile(path) {
        // First try direct plugin access (if withGlobalTauri is enabled)
        if (window.__TAURI__?.fs?.readTextFile) {
            console.log('Using direct fs.readTextFile API');
            try {
                const content = await window.__TAURI__.fs.readTextFile(path);
                return content;
            } catch (err) {
                console.error('Direct fs.readTextFile failed:', err);
            }
        }
        
        // Fallback to invoke
        if (!tauriInvoke) {
            console.error('tauriInvoke not available and fs plugin not found');
            return null;
        }
        try {
            console.log('Reading file via invoke:', path);
            // Tauri v2: invoke format for fs plugin
            const content = await tauriInvoke('plugin:fs|read_text_file', { 
                path,
                options: {}
            });
            console.log('File read successfully, length:', content?.length);
            return content;
        } catch (err) {
            console.error('Read file error:', err);
            throw err;
        }
    }
    
    // FS plugin wrapper - write text file
    async function tauriWriteTextFile(path, contents) {
        if (!tauriInvoke) return;
        try {
            await tauriInvoke('plugin:fs|write_text_file', { 
                path,
                contents,
                options: {}
            });
        } catch (err) {
            console.error('Write file error:', err);
            throw err;
        }
    }
    
    // Dialog plugin wrapper - save file dialog
    async function tauriDialogSave(options) {
        if (!tauriInvoke) return null;
        try {
            const result = await tauriInvoke('plugin:dialog|save', { options });
            return result;
        } catch (err) {
            console.error('Dialog save error:', err);
            throw err;
        }
    }
    
    // Dialog plugin wrapper - ask confirmation
    async function tauriDialogAsk(message, options = {}) {
        if (!tauriInvoke) return false;
        try {
            const result = await tauriInvoke('plugin:dialog|ask', { 
                message, 
                title: options.title || 'Confirm',
                kind: options.kind || 'info'
            });
            return result;
        } catch (err) {
            console.error('Dialog ask error:', err);
            return false;
        }
    }

    // =============================================
    // Unified File Processing Functions
    // =============================================
    
    // Process XML content (shared by browser and Tauri)
    function processXmlContent(content, filename) {
        const parser = new DOMParser();
        const parsedDoc = parser.parseFromString(content, "text/xml");
        
        // Check for parser errors
        const parserError = parsedDoc.getElementsByTagName("parsererror")[0] || 
                            parsedDoc.querySelector("parsererror");
        if (parserError) {
            const errorMsg = 'XML 解析错误: ' + parserError.textContent;
            console.error("XML Parser Error:", parserError.textContent);
            if (isTauri && tauriInvoke) {
                tauriDialogMessage(errorMsg, { title: 'Error', kind: 'error' });
            } else {
                alert(errorMsg);
            }
            return false;
        }
        
        // Check if we have a valid document element
        if (!parsedDoc.documentElement || parsedDoc.documentElement.nodeName === "html") {
            const errorMsg = "无效的 XML 文档结构";
            console.error("Invalid XML document structure");
            if (isTauri && tauriInvoke) {
                tauriDialogMessage(errorMsg, { title: 'Error', kind: 'error' });
            } else {
                alert(errorMsg);
            }
            return false;
        }
        
        // Store the parsed document and raw content
        xmlDoc = parsedDoc;
        xmlRawContent = content;
        xmlFilename = filename;
        
        // Reset states for new file
        currentNodePath = null;
        currentNode = null;
        xmlViewRendered = false;
        
        // Update UI
        dropZoneText.textContent = filename;
        
        // Render tree
        try {
            renderTree(xmlDoc);
        } catch (err) {
            console.error("Error rendering tree:", err);
            const errorMsg = "树渲染错误: " + err.message;
            if (isTauri && tauriInvoke) {
                tauriDialogMessage(errorMsg, { title: 'Error', kind: 'error' });
            } else {
                alert(errorMsg);
            }
            return false;
        }
        
        // Reset detail view
        try {
            resetDetailView();
        } catch (err) {
            console.error("Error resetting detail view:", err);
        }
        
        // If currently on XML view, render it
        if (currentView === 'xml') {
            renderXmlView();
        }
        
        // Save state to localStorage
        saveStateToStorage();
        return true;
    }
    
    // Process Help Schema content (shared by browser and Tauri)
    function processHelpSchemaContent(content, filename) {
        try {
            const parsed = JSON.parse(content);
            
            // Validate basic structure
            if (!parsed.definitions && !parsed.paths) {
                const errorMsg = '帮助配置文件格式无效：缺少 definitions 或 paths';
                if (isTauri && tauriInvoke) {
                    tauriDialogMessage(errorMsg, { title: 'Error', kind: 'error' });
                } else {
                    alert(errorMsg);
                }
                return false;
            }
            
            // Process the schema (resolve $ref references)
            helpSchema = processHelpSchema(parsed);
            helpSchemaRaw = content;
            helpSchemaFilename = filename;
            
            // Update UI
            helpUploadBtn.classList.add('loaded');
            helpStatusText.textContent = filename;
            helpStatusText.title = filename;
            
            // Re-render tree and details to apply help
            if (xmlDoc) {
                renderTree(xmlDoc);
                if (currentNode) {
                    showNodeDetails(currentNode);
                }
            }
            
            // Save to localStorage
            saveStateToStorage();
            return true;
            
        } catch (err) {
            console.error('Help schema parse error:', err);
            const errorMsg = '帮助配置文件解析错误: ' + err.message;
            if (isTauri && tauriInvoke) {
                tauriDialogMessage(errorMsg, { title: 'Error', kind: 'error' });
            } else {
                alert(errorMsg);
            }
            return false;
        }
    }

    // =============================================
    // Tauri File Operations
    // =============================================
    
    // Open XML file using Tauri native dialog
    async function tauriOpenXmlFile() {
        if (!tauriInvoke) {
            console.error('Tauri invoke not available');
            return;
        }
        
        try {
            console.log('Opening XML file dialog...');
            const filePath = await tauriDialogOpen({
                multiple: false,
                filters: [{
                    name: 'XML Files',
                    extensions: ['xml']
                }]
            });
            
            console.log('Selected file:', filePath);
            
            if (filePath) {
                const content = await tauriReadTextFile(filePath);
                currentFilePath = filePath;
                
                // Extract filename from path
                const filename = filePath.split('/').pop().split('\\').pop();
                
                // Process the XML content
                processXmlContent(content, filename);
            }
        } catch (err) {
            console.error('Error opening file:', err);
            await tauriDialogMessage('打开文件失败: ' + err.message, { title: 'Error', kind: 'error' });
        }
    }
    
    // Open Help Schema file using Tauri native dialog
    async function tauriOpenHelpFile() {
        if (!tauriInvoke) {
            console.error('Tauri invoke not available');
            return;
        }
        
        try {
            console.log('Opening Help file dialog...');
            const filePath = await tauriDialogOpen({
                multiple: false,
                filters: [{
                    name: 'JSON Files',
                    extensions: ['json']
                }]
            });
            
            console.log('Selected help file:', filePath);
            
            if (filePath) {
                const content = await tauriReadTextFile(filePath);
                currentHelpFilePath = filePath;
                
                // Extract filename from path
                const filename = filePath.split('/').pop().split('\\').pop();
                
                // Process the help schema content
                processHelpSchemaContent(content, filename);
            }
        } catch (err) {
            console.error('Error opening help file:', err);
            await tauriDialogMessage('打开帮助配置文件失败: ' + err.message, { title: 'Error', kind: 'error' });
        }
    }
    
    // Expose Tauri functions globally for menu integration
    if (isTauri) {
        window.tauriOpenFile = tauriOpenXmlFile;
        window.tauriOpenHelpFile = tauriOpenHelpFile;
    }

    // =============================================
    // Event Listeners (Environment-aware)
    // =============================================
    
    // --- XML Drop Zone Event Listeners ---
    if (isTauri) {
        // Tauri: Use native dialog on click
        console.log('Setting up Tauri click handler for dropZone');
        dropZone.addEventListener('click', (e) => {
            console.log('DropZone clicked!', e);
            e.preventDefault();
            e.stopPropagation();
            tauriOpenXmlFile().catch(err => {
                console.error('Error in tauriOpenXmlFile:', err);
            });
        });
        dropZone.style.cursor = 'pointer';
        dropZoneText.textContent = 'CLICK TO OPEN XML FILE OR DRAG & DROP';
        console.log('✅ Tauri click handler set up');
        
        // Use Tauri's event system for drag and drop (not HTML events)
        if (window.__TAURI__?.event) {
            console.log('Setting up Tauri drag-drop event listener');
            let isOverDropZone = false;
            
            // Track mouse position to know if we're over the drop zone
            dropZone.addEventListener('mouseenter', () => {
                console.log('Mouse entered dropZone');
                isOverDropZone = true;
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('mouseleave', () => {
                console.log('Mouse left dropZone');
                isOverDropZone = false;
                dropZone.classList.remove('dragover');
            });
            
            // Listen to Tauri's drag-drop event
            window.__TAURI__.event.listen('tauri://drag-drop', async (event) => {
                console.log('Tauri drag-drop event:', event);
                console.log('isOverDropZone:', isOverDropZone);
                console.log('Payload:', event.payload);
                
                if (isOverDropZone && event.payload && event.payload.paths && event.payload.paths.length > 0) {
                    const filePath = event.payload.paths[0];
                    console.log('Dropped file path:', filePath);
                    
                    if (filePath.toLowerCase().endsWith('.xml')) {
                        try {
                            const content = await tauriReadTextFile(filePath);
                            currentFilePath = filePath;
                            const filename = filePath.split('/').pop().split('\\').pop();
                            processXmlContent(content, filename);
                        } catch (err) {
                            console.error('Error reading dropped XML file:', err);
                            await tauriDialogMessage('读取拖放文件失败: ' + err.message, { title: 'Error', kind: 'error' });
                        }
                    } else {
                        console.warn('Invalid file type:', filePath);
                        await tauriDialogMessage('请拖放 XML 格式的文件', { title: 'Warning', kind: 'warning' });
                    }
                }
                
                // Clean up visual feedback
                isOverDropZone = false;
                dropZone.classList.remove('dragover');
            });
            
            console.log('✅ Tauri drag-drop event listener set up');
        } else {
            console.error('Tauri event API not available');
        }
    } else {
        // Browser: Use file input
        console.log('Setting up browser click handler for dropZone');
        dropZone.addEventListener('click', () => {
            console.log('DropZone clicked (browser mode)');
            fileInput.click();
        });
        
        // Browser: Use HTML5 drag and drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Dragover event on dropZone');
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            console.log('Dragleave event on dropZone');
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('dragover');
            
            console.log('Drop event triggered', e);
            console.log('dataTransfer.files:', e.dataTransfer.files);
            
            if (e.dataTransfer.files.length) {
                console.log('Browser drop - handling file');
                handleFile(e.dataTransfer.files[0]);
            }
        });
    }

    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length) {
            handleFile(e.target.files[0]);
        }
    });
    
    helpFileInput.addEventListener('change', (e) => {
        if (e.target.files.length) {
            handleHelpSchemaFile(e.target.files[0]);
        }
    });

    // --- Help Schema Upload Event Listeners ---
    if (isTauri) {
        // Tauri: Use native dialog on click
        console.log('Setting up Tauri click handler for helpUploadBtn');
        helpUploadBtn.addEventListener('click', (e) => {
            console.log('HelpUploadBtn clicked!', e);
            e.preventDefault();
            e.stopPropagation();
            tauriOpenHelpFile().catch(err => {
                console.error('Error in tauriOpenHelpFile:', err);
            });
        });
        console.log('✅ Tauri help button handler set up');
        
        // Use Tauri's event system for drag and drop on help zone
        if (window.__TAURI__?.event) {
            console.log('Setting up Tauri drag-drop event listener for helpDropZone');
            let isOverHelpDropZone = false;
            
            // Track mouse position to know if we're over the help drop zone
            helpDropZone.addEventListener('mouseenter', () => {
                console.log('Mouse entered helpDropZone');
                isOverHelpDropZone = true;
                helpDropZone.classList.add('dragover');
            });
            
            helpDropZone.addEventListener('mouseleave', () => {
                console.log('Mouse left helpDropZone');
                isOverHelpDropZone = false;
                helpDropZone.classList.remove('dragover');
            });
            
            // Listen to Tauri's drag-drop event for help schema
            window.__TAURI__.event.listen('tauri://drag-drop', async (event) => {
                if (isOverHelpDropZone && event.payload && event.payload.paths && event.payload.paths.length > 0) {
                    const filePath = event.payload.paths[0];
                    console.log('Dropped help file path:', filePath);
                    
                    if (filePath.toLowerCase().endsWith('.json')) {
                        try {
                            const content = await tauriReadTextFile(filePath);
                            currentHelpFilePath = filePath;
                            const filename = filePath.split('/').pop().split('\\').pop();
                            processHelpSchemaContent(content, filename);
                        } catch (err) {
                            console.error('Error reading dropped help file:', err);
                            await tauriDialogMessage('读取帮助配置文件失败: ' + err.message, { title: 'Error', kind: 'error' });
                        }
                    } else {
                        console.warn('Invalid help file type:', filePath);
                        await tauriDialogMessage('请上传 JSON 格式的帮助配置文件', { title: 'Warning', kind: 'warning' });
                    }
                }
                
                // Clean up visual feedback
                isOverHelpDropZone = false;
                helpDropZone.classList.remove('dragover');
            });
            
            console.log('✅ Tauri drag-drop event listener for helpDropZone set up');
        }
    } else {
        // Browser: Use file input
        console.log('Setting up browser click handler for helpUploadBtn');
        helpUploadBtn.addEventListener('click', () => {
            console.log('HelpUploadBtn clicked (browser mode)');
            helpFileInput.click();
        });
        
        // Browser: Use HTML5 drag and drop for help zone
        helpDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Dragover event on helpDropZone');
            helpDropZone.classList.add('dragover');
        });
        
        helpDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Dragleave event on helpDropZone');
            helpDropZone.classList.remove('dragover');
        });
        
        helpDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            helpDropZone.classList.remove('dragover');
            
            console.log('Drop event on helpDropZone', e);
            console.log('helpDropZone dataTransfer.files:', e.dataTransfer.files);
            
            if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                if (file.name.endsWith('.json')) {
                    handleHelpSchemaFile(file);
                } else {
                    alert('请上传 JSON 格式的帮助配置文件');
                }
            }
        });
    }

    // --- Search Event Listeners ---
    searchInput.addEventListener('input', (e) => {
        searchText = e.target.value;
        if (currentNode) {
            showNodeDetails(currentNode);
        }
        saveStateToStorage();
    });

    document.querySelectorAll('input[name="search-scope"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            searchScope = e.target.value;
            if (currentNode) {
                showNodeDetails(currentNode);
            }
            saveStateToStorage();
        });
    });

    // --- Tree Search & Sort Event Listeners ---
    treeSearchInput.addEventListener('input', (e) => {
        treeSearchText = e.target.value;
        if (xmlDoc) {
            renderTree(xmlDoc);
        }
        saveStateToStorage();
    });

    document.querySelectorAll('input[name="tree-search-scope"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            treeSearchScope = e.target.value;
            if (xmlDoc) {
                renderTree(xmlDoc);
            }
            saveStateToStorage();
        });
    });

    treeSortBtn.addEventListener('click', () => {
        // Cycle through sort states
        if (treeSortState === 'natural') {
            treeSortState = 'asc';
            treeSortIcon.textContent = '▲';
        } else if (treeSortState === 'asc') {
            treeSortState = 'desc';
            treeSortIcon.textContent = '▼';
        } else {
            treeSortState = 'natural';
            treeSortIcon.textContent = '↕';
        }
        
        if (xmlDoc) {
            renderTree(xmlDoc);
        }
        saveStateToStorage();
    });

    treeToggleBtn.addEventListener('click', () => {
        treeExpanded = !treeExpanded;
        
        // Update button icon and text
        if (treeExpanded) {
            treeToggleIcon.textContent = '⊟';
            treeToggleText.textContent = '折叠';
        } else {
            treeToggleIcon.textContent = '⊞';
            treeToggleText.textContent = '展开';
        }
        
        // Toggle all tree nodes
        const treeNodes = treeContainer.querySelectorAll('.tree-node:not(.leaf-node)');
        treeNodes.forEach(node => {
            if (treeExpanded) {
                node.classList.add('expanded');
            } else {
                node.classList.remove('expanded');
            }
        });
        saveStateToStorage();
    });

    // --- View Tab Event Listeners ---
    viewTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            switchView(tab.dataset.view);
        });
    });

    // XML View toolbar buttons
    document.getElementById('xml-fold-all').addEventListener('click', foldAllXmlNodes);
    document.getElementById('xml-unfold-all').addEventListener('click', unfoldAllXmlNodes);

    // --- New Button Event Listeners ---
    // Reset button
    resetBtn.addEventListener('click', resetApplication);
    
    // Help button
    helpBtn.addEventListener('click', showHelpModal);
    
    // Theme toggle button
    themeToggleBtn.addEventListener('click', toggleTheme);
    
    // Language toggle button
    langToggleBtn.addEventListener('click', toggleLanguage);
    
    // Help modal close button
    helpModalClose.addEventListener('click', hideHelpModal);
    
    // Help modal overlay click
    helpModal.querySelector('.modal-overlay').addEventListener('click', hideHelpModal);
    
    // ESC key to close help modal
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && helpModal.classList.contains('visible')) {
            hideHelpModal();
        }
        // ESC key to close mobile detail panel
        if (e.key === 'Escape' && window.innerWidth <= 768) {
            const detailPanel = document.getElementById('detail-panel');
            if (detailPanel && detailPanel.classList.contains('visible')) {
                closeDetailMobile();
            }
        }
        // ESC key to close mobile menu
        if (e.key === 'Escape') {
            const mobileMenu = document.getElementById('mobile-menu');
            if (mobileMenu && mobileMenu.classList.contains('visible')) {
                closeMobileMenu();
            }
        }
    });

    // =============================================
    // Mobile Menu Functions
    // =============================================
    
    // Mobile hamburger menu button
    const mobileHamburgerBtn = document.getElementById('mobile-hamburger-btn');
    const mobileMenu = document.getElementById('mobile-menu');
    const mobileMenuClose = document.querySelector('.mobile-menu-close');
    const mobileMenuOverlay = document.querySelector('.mobile-menu-overlay');
    
    // Mobile menu item buttons
    const mobileThemeToggleBtn = document.getElementById('mobile-theme-toggle-btn');
    const mobileLangToggleBtn = document.getElementById('mobile-lang-toggle-btn');
    const mobileHelpBtn = document.getElementById('mobile-help-btn');
    const mobileResetBtn = document.getElementById('mobile-reset-btn');
    const mobileHelpUploadBtn = document.getElementById('mobile-help-upload-btn');
    
    function openMobileMenu() {
        mobileMenu.classList.add('visible');
        document.body.style.overflow = 'hidden'; // Prevent body scroll
    }
    
    function closeMobileMenu() {
        mobileMenu.classList.remove('visible');
        document.body.style.overflow = ''; // Restore body scroll
    }
    
    // Event listeners for mobile menu
    if (mobileHamburgerBtn) {
        mobileHamburgerBtn.addEventListener('click', openMobileMenu);
    }
    
    if (mobileMenuClose) {
        mobileMenuClose.addEventListener('click', closeMobileMenu);
    }
    
    if (mobileMenuOverlay) {
        mobileMenuOverlay.addEventListener('click', closeMobileMenu);
    }
    
    // Mobile menu item actions
    if (mobileThemeToggleBtn) {
        mobileThemeToggleBtn.addEventListener('click', () => {
            toggleTheme();
            // Update mobile menu icon
            const mobileThemeIcon = document.getElementById('mobile-theme-icon');
            if (mobileThemeIcon) {
                mobileThemeIcon.textContent = currentTheme === 'dark' ? 'light_mode' : 'dark_mode';
            }
        });
    }
    
    if (mobileLangToggleBtn) {
        mobileLangToggleBtn.addEventListener('click', () => {
            toggleLanguage();
            closeMobileMenu();
        });
    }
    
    if (mobileHelpBtn) {
        mobileHelpBtn.addEventListener('click', () => {
            showHelpModal();
            closeMobileMenu();
        });
    }
    
    if (mobileResetBtn) {
        mobileResetBtn.addEventListener('click', () => {
            closeMobileMenu();
            setTimeout(() => resetApplication(), 100);
        });
    }
    
    // Mobile help schema upload
    if (mobileHelpUploadBtn) {
        if (isTauri) {
            mobileHelpUploadBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                tauriOpenHelpFile().catch(err => {
                    console.error('Error in tauriOpenHelpFile:', err);
                });
            });
        } else {
            mobileHelpUploadBtn.addEventListener('click', () => {
                helpFileInput.click();
            });
        }
    }
    
    // =============================================
    // Mobile Detail Panel Functions
    // =============================================
    
    const mobileDetailOverlay = document.getElementById('mobile-detail-overlay');
    const mobileDetailClose = document.querySelector('.mobile-detail-close');
    
    function showDetailMobile() {
        if (window.innerWidth <= 768) {
            const detailPanel = document.getElementById('detail-panel');
            detailPanel.classList.add('visible');
            mobileDetailOverlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
        }
    }
    
    function closeDetailMobile() {
        const detailPanel = document.getElementById('detail-panel');
        detailPanel.classList.remove('visible');
        mobileDetailOverlay.classList.remove('visible');
        document.body.style.overflow = '';
    }
    
    // Event listeners for mobile detail panel
    if (mobileDetailClose) {
        mobileDetailClose.addEventListener('click', closeDetailMobile);
    }
    
    if (mobileDetailOverlay) {
        mobileDetailOverlay.addEventListener('click', closeDetailMobile);
    }
    
    // =============================================
    // Mobile Chip Buttons
    // =============================================
    
    // Tree search scope chips
    const treeChips = document.querySelectorAll('.tree-controls .mobile-chips .chip-btn');
    treeChips.forEach(btn => {
        btn.addEventListener('click', (e) => {
            // Use closest() to get the actual button, not the inner span
            const chipBtn = e.target.closest('.chip-btn');
            if (!chipBtn) return;
            
            const parent = chipBtn.closest('.mobile-chips');
            parent.querySelectorAll('.chip-btn').forEach(b => b.classList.remove('active'));
            chipBtn.classList.add('active');
            
            const scope = chipBtn.dataset.scope;
            treeSearchScope = scope;
            
            // Update radio button for consistency
            const radio = document.querySelector(`input[name="tree-search-scope"][value="${scope}"]`);
            if (radio) radio.checked = true;
            
            // Re-render tree
            if (xmlDoc) {
                renderTree(xmlDoc);
            }
            saveStateToStorage();
        });
    });
    
    // Detail search scope chips
    const detailChips = document.querySelectorAll('.search-filter-bar .mobile-chips .chip-btn');
    detailChips.forEach(btn => {
        btn.addEventListener('click', (e) => {
            // Use closest() to get the actual button, not the inner span
            const chipBtn = e.target.closest('.chip-btn');
            if (!chipBtn) return;
            
            const parent = chipBtn.closest('.mobile-chips');
            parent.querySelectorAll('.chip-btn').forEach(b => b.classList.remove('active'));
            chipBtn.classList.add('active');
            
            const scope = chipBtn.dataset.scope;
            searchScope = scope;
            
            // Update radio button for consistency
            const radio = document.querySelector(`input[name="search-scope"][value="${scope}"]`);
            if (radio) radio.checked = true;
            
            // Re-render details
            if (currentNode) {
                showNodeDetails(currentNode);
            }
            saveStateToStorage();
        });
    });
    
    // Update radio button listeners to sync with chips
    document.querySelectorAll('input[name="tree-search-scope"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            // Sync chip button
            const chip = document.querySelector(`.tree-controls .mobile-chips .chip-btn[data-scope="${e.target.value}"]`);
            if (chip) {
                document.querySelectorAll('.tree-controls .mobile-chips .chip-btn').forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            }
        });
    });
    
    document.querySelectorAll('input[name="search-scope"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            // Sync chip button
            const chip = document.querySelector(`.search-filter-bar .mobile-chips .chip-btn[data-scope="${e.target.value}"]`);
            if (chip) {
                document.querySelectorAll('.search-filter-bar .mobile-chips .chip-btn').forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            }
        });
    });


    // --- File Handling ---
    function handleFile(file) {
        if (file.type !== "text/xml" && !file.name.endsWith(".xml")) {
            alert("PLEASE UPLOAD A VALID XML FILE.");
            return;
        }

        dropZoneText.textContent = file.name;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const parser = new DOMParser();
            const rawContent = e.target.result;
            
            // Step 1: Parse XML
            const parsedDoc = parser.parseFromString(rawContent, "text/xml");
            
            // Step 2: Check for parser errors (handle namespaced parsererror)
            const parserError = parsedDoc.getElementsByTagName("parsererror")[0] || 
                                parsedDoc.querySelector("parsererror");
            if (parserError) {
                console.error("XML Parser Error:", parserError.textContent);
                alert("XML 解析错误: " + parserError.textContent);
                return;
            }
            
            // Step 3: Check if we have a valid document element
            if (!parsedDoc.documentElement || parsedDoc.documentElement.nodeName === "html") {
                console.error("Invalid XML document structure");
                alert("无效的 XML 文档结构");
                return;
            }
            
            // Store the parsed document and raw content
            xmlDoc = parsedDoc;
            xmlRawContent = rawContent;
            xmlFilename = file.name;
            
            // Reset states for new file
            currentNodePath = null;
            currentNode = null;
            xmlViewRendered = false; // Force re-render of XML view
            
            // Step 4: Render tree
            try {
                renderTree(xmlDoc);
            } catch (err) {
                console.error("Error rendering tree:", err);
                alert("树渲染错误: " + err.message);
                return;
            }
            
            // Step 5: Reset detail view
            try {
                resetDetailView();
            } catch (err) {
                console.error("Error resetting detail view:", err);
                alert("重置详情面板错误: " + err.message);
            }
            
            // Step 6: If currently on XML view, render it
            if (currentView === 'xml') {
                renderXmlView();
            }
            
            // Save state to localStorage
            saveStateToStorage();
        };
        
        reader.onerror = (err) => {
            console.error("FileReader error:", err);
            alert("ERROR READING FILE.");
        };
        
        reader.readAsText(file);
    }

    // --- Help Schema Handling ---
    function handleHelpSchemaFile(file) {
        if (!file.name.endsWith('.json')) {
            alert('请上传 JSON 格式的帮助配置文件');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const rawContent = e.target.result;
                const parsed = JSON.parse(rawContent);
                
                // Validate basic structure
                if (!parsed.definitions && !parsed.paths) {
                    alert('帮助配置文件格式无效：缺少 definitions 或 paths');
                    return;
                }
                
                // Process the schema (resolve $ref references)
                helpSchema = processHelpSchema(parsed);
                helpSchemaRaw = rawContent;
                helpSchemaFilename = file.name;
                
                // Update UI
                helpUploadBtn.classList.add('loaded');
                helpStatusText.textContent = file.name;
                helpStatusText.title = file.name; // Show full name on hover
                
                // Re-render tree and details to apply help
                if (xmlDoc) {
                    renderTree(xmlDoc);
                    if (currentNode) {
                        showNodeDetails(currentNode);
                    }
                }
                
                // Save to localStorage
                saveStateToStorage();
                
            } catch (err) {
                console.error('Help schema parse error:', err);
                alert('帮助配置文件解析错误: ' + err.message);
            }
        };
        
        reader.onerror = () => {
            alert('读取帮助配置文件失败');
        };
        
        reader.readAsText(file);
    }

    // Process help schema and resolve $ref references
    function processHelpSchema(schema) {
        const processed = {
            definitions: schema.definitions || {},
            paths: {},
            wildcardPaths: [] // Store wildcard patterns for matching
        };
        
        // Process paths and resolve $ref
        if (schema.paths) {
            for (const [path, value] of Object.entries(schema.paths)) {
                const resolved = resolveRef(value, schema);
                
                if (path.includes('**')) {
                    // Store wildcard patterns separately
                    processed.wildcardPaths.push({
                        pattern: path,
                        regex: wildcardToRegex(path),
                        help: resolved
                    });
                } else {
                    processed.paths[path] = resolved;
                }
            }
        }
        
        return processed;
    }

    // Resolve $ref references in help schema
    function resolveRef(value, schema) {
        if (!value || typeof value !== 'object') {
            return value;
        }
        
        if (value.$ref) {
            // Parse $ref path like "#/definitions/Hotel_Code"
            const refPath = value.$ref;
            if (refPath.startsWith('#/definitions/')) {
                const defName = refPath.substring('#/definitions/'.length);
                if (schema.definitions && schema.definitions[defName]) {
                    return { ...schema.definitions[defName] };
                }
            }
            return null;
        }
        
        return value;
    }

    // Convert wildcard pattern to regex
    function wildcardToRegex(pattern) {
        // ** matches any number of path segments
        // * matches single path segment
        const escaped = pattern
            .replace(/\./g, '\\.')
            .replace(/\*\*/g, '##DOUBLE##')
            .replace(/\*/g, '[^.]+')
            .replace(/##DOUBLE##/g, '.*');
        return new RegExp('^' + escaped + '$');
    }

    // Find help content for a given path or tag name
    function findHelpContent(path, tagName) {
        if (!helpSchema) return null;
        
        // 1. Try exact path match
        if (helpSchema.paths[path]) {
            return helpSchema.paths[path];
        }
        
        // 2. Try wildcard path match
        for (const wp of helpSchema.wildcardPaths) {
            if (wp.regex.test(path)) {
                return wp.help;
            }
        }
        
        // 3. Try tag name match in definitions
        if (helpSchema.definitions[tagName]) {
            return helpSchema.definitions[tagName];
        }
        
        // 4. Try tag name without @ prefix (for attributes)
        if (tagName.startsWith('@')) {
            const attrName = tagName.substring(1);
            if (helpSchema.definitions[attrName]) {
                return helpSchema.definitions[attrName];
            }
        }
        
        // 5. Try partial path match (last segment of path)
        const pathParts = path.split('.');
        for (let i = pathParts.length - 1; i >= 0; i--) {
            const partialPath = pathParts.slice(i).join('.');
            if (helpSchema.paths[partialPath]) {
                return helpSchema.paths[partialPath];
            }
        }
        
        return null;
    }

    // --- Validation Functions ---
    // Validate a value against help schema definition
    function validateValue(value, helpContent) {
        const result = { valid: true, errors: [] };
        
        if (!helpContent) return result;
        
        // Handle value - could be undefined, null, or empty string
        const trimmedValue = (value === undefined || value === null) ? '' : String(value).trim();
        
        // 1. Required validation - check for true, "true", or 1
        const isRequired = helpContent.required === true || 
                          helpContent.required === 'true' || 
                          helpContent.required === 1;
        
        if (isRequired && trimmedValue === '') {
            result.valid = false;
            result.errors.push(t('requiredField'));
            return result; // No need to continue if empty and required
        }
        
        // Skip other validations if value is empty and not required
        if (trimmedValue === '') return result;
        
        // 2. Type validation
        if (helpContent.type) {
            const typeError = validateType(trimmedValue, helpContent.type, helpContent.format);
            if (typeError) {
                result.valid = false;
                result.errors.push(typeError);
            }
        }
        
        // 3. Format validation (regex) - only for string type or when type is not date
        if (helpContent.format && helpContent.type !== 'date') {
            try {
                const regex = new RegExp(helpContent.format);
                if (!regex.test(trimmedValue)) {
                    result.valid = false;
                    result.errors.push(`${t('formatMismatch')}: ${helpContent.format}`);
                }
            } catch (e) {
                // Invalid regex in schema, skip validation
                console.warn('Invalid regex in schema:', helpContent.format);
            }
        }
        
        return result;
    }
    
    // Validate value type
    function validateType(value, type, format) {
        switch (type.toLowerCase()) {
            case 'string':
                // String type accepts anything
                return null;
                
            case 'integer':
                if (!/^-?\d+$/.test(value)) {
                    return `${t('typeError')}：${t('expectInteger')} "${value}"`;
                }
                return null;
                
            case 'number':
                if (isNaN(parseFloat(value)) || !isFinite(value)) {
                    return `${t('typeError')}：${t('expectNumber')} "${value}"`;
                }
                return null;
                
            case 'date':
                return validateDateFormat(value, format);
                
            case 'boolean':
                if (!['true', 'false', '1', '0', 'yes', 'no'].includes(value.toLowerCase())) {
                    return `${t('typeError')}：${t('expectBoolean')} "${value}"`;
                }
                return null;
                
            default:
                return null;
        }
    }
    
    // Validate date format
    function validateDateFormat(value, format) {
        if (!format) {
            // Try common date formats
            const datePatterns = [
                /^\d{4}-\d{2}-\d{2}$/,           // YYYY-MM-DD
                /^\d{2}\/\d{2}\/\d{4}$/,         // MM/DD/YYYY
                /^\d{2}\/\d{2}\/\d{2}$/,         // MM/DD/YY
                /^\d{4}\/\d{2}\/\d{2}$/          // YYYY/MM/DD
            ];
            
            if (!datePatterns.some(p => p.test(value))) {
                return `${t('dateFormatError')}：${t('unrecognizedDateFormat')} "${value}"`;
            }
            return null;
        }
        
        // Convert format pattern to regex
        let pattern = format
            .replace('YYYY', '\\d{4}')
            .replace('YY', '\\d{2}')
            .replace('MM', '\\d{2}')
            .replace('DD', '\\d{2}')
            .replace('HH', '\\d{2}')
            .replace('mm', '\\d{2}')
            .replace('ss', '\\d{2}');
        
        try {
            const regex = new RegExp('^' + pattern + '$');
            if (!regex.test(value)) {
                return `${t('dateFormatError')}：${t('expectFormat')} ${format}，${t('actualValue')} "${value}"`;
            }
        } catch (e) {
            // Invalid pattern, skip
        }
        
        return null;
    }

    // --- Tooltip Functions ---
    let tooltipTimeout = null;
    let isMouseInTooltip = false;
    
    // Add tooltip mouse event listeners
    helpTooltip.addEventListener('mouseenter', () => {
        isMouseInTooltip = true;
        // Cancel any pending hide
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
    });
    
    helpTooltip.addEventListener('mouseleave', () => {
        isMouseInTooltip = false;
        hideTooltip();
    });
    
    function showTooltip(element, helpContent, nodePath, errors) {
        if (!helpContent && (!errors || errors.length === 0)) return;
        
        // Clear any pending hide
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        
        // Build tooltip content with errors and help
        let fullHtml = '';
        
        // Add error section if there are errors
        if (errors && errors.length > 0) {
            fullHtml += `
                <div class="help-tooltip-error">
                    <div class="help-tooltip-error-title">${t('validationErrors')}</div>
                    <ul class="help-tooltip-error-list">
                        ${errors.map(err => `<li>${escapeHtml(err)}</li>`).join('')}
                    </ul>
                </div>`;
        }
        
        // Add help content section
        if (helpContent) {
            fullHtml += `<div class="help-tooltip-header">${escapeHtml(nodePath || '')}</div>`;
            
            let bodyHtml = '';
            
            if (helpContent.description) {
                bodyHtml += `<div class="help-tooltip-desc">${escapeHtml(helpContent.description)}</div>`;
            }
            
            if (helpContent.type) {
                bodyHtml += `
                    <div class="help-tooltip-row">
                        <span class="help-tooltip-label">${t('type')}</span>
                        <span class="help-tooltip-value">${escapeHtml(helpContent.type)}</span>
                    </div>`;
            }
            
            if (helpContent.format) {
                bodyHtml += `
                    <div class="help-tooltip-row">
                        <span class="help-tooltip-label">${t('format')}</span>
                        <span class="help-tooltip-value">${escapeHtml(helpContent.format)}</span>
                    </div>`;
            }
            
            if (helpContent.example !== undefined) {
                bodyHtml += `
                    <div class="help-tooltip-row">
                        <span class="help-tooltip-label">${t('example')}</span>
                        <span class="help-tooltip-value"><code class="help-tooltip-example">${escapeHtml(String(helpContent.example))}</code></span>
                    </div>`;
            }
            
            if (helpContent.required !== undefined) {
                bodyHtml += `
                    <div class="help-tooltip-row">
                        <span class="help-tooltip-label">${t('required')}</span>
                        <span class="help-tooltip-value">${helpContent.required ? t('yes') : t('no')}</span>
                    </div>`;
            }
            
            fullHtml += `<div class="help-tooltip-body">${bodyHtml}</div>`;
        }
        
        // Update tooltip content
        helpTooltip.innerHTML = fullHtml;
        
        // Position tooltip near the element (below and slightly to the right)
        const rect = element.getBoundingClientRect();
        
        // Show tooltip below the element, aligned to its left edge
        let left = rect.left;
        let top = rect.bottom + 8;
        
        // Make tooltip visible temporarily to measure its size
        helpTooltip.style.visibility = 'hidden';
        helpTooltip.style.display = 'block';
        const tooltipWidth = helpTooltip.offsetWidth;
        const tooltipHeight = helpTooltip.offsetHeight;
        helpTooltip.style.visibility = '';
        helpTooltip.style.display = '';
        
        // Adjust if tooltip would go off right edge of screen
        if (left + tooltipWidth > window.innerWidth - 10) {
            left = window.innerWidth - tooltipWidth - 10;
        }
        
        // Adjust if tooltip would go off left edge
        if (left < 10) {
            left = 10;
        }
        
        // Track if we're showing above or below
        let showAbove = false;
        
        // If tooltip would go off bottom, show it above the element instead
        if (top + tooltipHeight > window.innerHeight - 10) {
            top = rect.top - tooltipHeight - 8;
            showAbove = true;
        }
        
        // If still off top, just position at top of screen
        if (top < 10) {
            top = 10;
            showAbove = false;
        }
        
        // Calculate arrow position to point at element center
        const arrowLeft = Math.max(12, Math.min(rect.left + rect.width / 2 - left - 6, tooltipWidth - 24));
        helpTooltip.style.setProperty('--arrow-left', arrowLeft + 'px');
        
        helpTooltip.style.left = left + 'px';
        helpTooltip.style.top = top + 'px';
        helpTooltip.classList.toggle('above', showAbove);
        helpTooltip.classList.add('visible');
    }
    
    function hideTooltip() {
        // Don't hide if mouse is inside tooltip
        if (isMouseInTooltip) return;
        
        tooltipTimeout = setTimeout(() => {
            // Double check mouse isn't in tooltip before hiding
            if (!isMouseInTooltip) {
                helpTooltip.classList.remove('visible');
                helpTooltip.classList.remove('above');
            }
        }, 150);
    }

    // --- View Switching ---
    function switchView(viewName) {
        if (currentView === viewName) return;
        
        currentView = viewName;
        
        // Update Tab styles
        viewTabs.forEach(tab => {
            tab.classList.toggle('active', tab.dataset.view === viewName);
        });
        
        // Toggle container visibility
        treeViewContainer.classList.toggle('active', viewName === 'tree');
        xmlViewContainer.classList.toggle('active', viewName === 'xml');
        
        // If switching to XML View and we have XML content, render it
        if (viewName === 'xml' && xmlRawContent) {
            if (!xmlViewRendered) {
                renderXmlView();
            }
        }
        
        saveStateToStorage();
    }

    // --- XML View Rendering ---
    function renderXmlView() {
        if (!xmlRawContent) {
            xmlContentEl.innerHTML = `
                <div class="xml-empty-state">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    <p>${t('xmlEmptyState')}</p>
                </div>`;
            return;
        }
        
        // Wait for Monaco to be loaded
        if (!window.monacoReady) {
            xmlContentEl.innerHTML = `
                <div class="xml-empty-state">
                    <p>${t('loadingEditor')}</p>
                </div>`;
            setTimeout(() => renderXmlView(), 200);
            return;
        }
        
        // Clear existing content
        xmlContentEl.innerHTML = '';
        
        try {
            // Destroy existing editor if any
            if (window.monacoEditor) {
                window.monacoEditor.dispose();
                window.monacoEditor = null;
            }
            
            // Create Monaco editor with theme based on current theme
            const monacoTheme = currentTheme === 'dark' ? 'vs-dark' : 'vs';
            window.monacoEditor = monaco.editor.create(xmlContentEl, {
                value: xmlRawContent,
                language: 'xml',
                theme: monacoTheme,
                readOnly: true,
                automaticLayout: true,
                minimap: { enabled: true },
                folding: true,
                foldingStrategy: 'indentation',
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                fontSize: 14,
                fontFamily: "'Consolas', 'Monaco', 'Fira Code', monospace"
            });
            
            // Update info
            updateXmlInfo();
            
            xmlViewRendered = true;
        } catch (err) {
            console.error('Monaco initialization error:', err);
            xmlContentEl.innerHTML = `
                <div class="xml-empty-state">
                    <p style="color: var(--error-border);">${t('editorInitFailed')}: ${err.message}</p>
                    <p style="font-size: 0.8rem; color: var(--secondary-text); margin-top: 0.5rem;">${t('checkConsole')}</p>
                </div>`;
        }
    }

    function foldAllXmlNodes() {
        if (window.monacoEditor) {
            // Monaco: 折叠所有可折叠区域
            window.monacoEditor.getAction('editor.foldAll').run();
            updateXmlInfo();
        }
    }

    function unfoldAllXmlNodes() {
        if (window.monacoEditor) {
            // Monaco: 展开所有折叠区域
            window.monacoEditor.getAction('editor.unfoldAll').run();
            updateXmlInfo();
        }
    }

    function updateXmlInfo() {
        if (!xmlRawContent) {
            xmlInfoEl.textContent = '';
            return;
        }
        
        const lines = xmlRawContent.split('\n').length;
        const size = (xmlRawContent.length / 1024).toFixed(2);
        xmlInfoEl.textContent = `${lines} ${t('lines')} | ${size} KB`;
    }

    // --- Tree Rendering ---
    function renderTree(doc) {
        try {
            treeContainer.innerHTML = '';
            const root = doc.documentElement;
            const rootNode = createTreeNode(root);
            if (rootNode) {
                treeContainer.appendChild(rootNode);
                
                // Show tree controls after rendering
                treeControls.classList.add('visible');
                
                // Restore selection if we have a saved path
                if (currentNodePath) {
                    setTimeout(() => restoreNodeSelection(currentNodePath), 0);
                }
            } else {
                treeContainer.innerHTML = `<div class="empty-state" style="height: auto; padding-top: 2rem;">${escapeHtml(t('noMatchingNodes'))}</div>`;
            }
        } catch (err) {
            console.error("Error rendering tree:", err);
            throw err;
        }
    }

    function createTreeNode(xmlNode) {
        // Check if this node should be shown based on search filter
        if (!shouldShowNode(xmlNode, treeSearchText, treeSearchScope)) {
            return null;
        }
        
        const hasChildren = hasElementChildren(xmlNode);
        
        // Container for the node
        const li = document.createElement('div');
        li.className = `tree-node ${hasChildren ? '' : 'leaf-node'}`;
        li.dataset.nodePath = getNodePath(xmlNode); // Store path for selection

        // The visible content line (Icon + Tag Name)
        const content = document.createElement('div');
        content.className = 'tree-content';
        
        // Arrow Icon
        const icon = document.createElement('span');
        icon.className = 'toggle-icon';
        icon.textContent = '▶'; 
        content.appendChild(icon);

        // Tag Name
        const title = document.createElement('span');
        title.className = 'tag-name';
        title.textContent = xmlNode.nodeName;
        
        // Add help indicator if help content exists
        const nodePath = getNodePath(xmlNode);
        const helpContent = findHelpContent(nodePath, xmlNode.nodeName);
        
        // Validate leaf node values
        let validationResult = { valid: true, errors: [] };
        const isLeafNode = !hasElementChildren(xmlNode);
        if (isLeafNode && helpContent) {
            const nodeValue = xmlNode.textContent.trim();
            validationResult = validateValue(nodeValue, helpContent);
        }
        
        // Add validation error styling and tooltip
        if (!validationResult.valid) {
            title.classList.add('validation-error');
            // Show combined tooltip with both errors and help content
            title.addEventListener('mouseenter', (e) => {
                showTooltip(title, helpContent, nodePath, validationResult.errors);
            });
            title.addEventListener('mouseleave', hideTooltip);
        } else if (helpContent) {
            // Show help tooltip only
            title.classList.add('has-help');
            title.addEventListener('mouseenter', (e) => {
                showTooltip(title, helpContent, nodePath, null);
            });
            title.addEventListener('mouseleave', hideTooltip);
        }
        
        content.appendChild(title);

        // Click Handler: Selection & Toggling
        content.onclick = (e) => {
            e.stopPropagation();
            
            // Clear previous selection and parent path highlights
            document.querySelectorAll('.tree-content.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.tree-content.parent-path').forEach(el => el.classList.remove('parent-path'));
            
            // Add selected class to current node
            content.classList.add('selected');
            
            // Highlight parent path from current node to root
            let parentElement = li.parentElement;
            while (parentElement) {
                if (parentElement.classList && parentElement.classList.contains('tree-node')) {
                    const parentContent = parentElement.querySelector(':scope > .tree-content');
                    if (parentContent) {
                        parentContent.classList.add('parent-path');
                    }
                }
                parentElement = parentElement.parentElement;
            }

            // Save current node and path
            currentNode = xmlNode;
            currentNodePath = getNodePath(xmlNode);

            // Reset detail panel sort state when selecting a new node
            sortState = 'natural';

            // Show Details
            showNodeDetails(xmlNode);

            // Toggle Expansion if it has children
            if (hasChildren) {
                li.classList.toggle('expanded');
            }
            
            // Save state to localStorage
            saveStateToStorage();
        };

        li.appendChild(content);

        // Recursively build children
        if (hasChildren) {
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'node-children';
            
            // Apply sorting to children
            const sortedChildren = sortTreeChildren(xmlNode.children, treeSortState);
            
            sortedChildren.forEach(child => {
                const childNode = createTreeNode(child);
                if (childNode) { // Only append if not filtered out
                    childrenContainer.appendChild(childNode);
                }
            });
            
            // Only add children container if it has visible children
            if (childrenContainer.children.length > 0) {
                li.appendChild(childrenContainer);
            } else if (!nodeMatchesSearch(xmlNode, treeSearchText, treeSearchScope)) {
                // If no children are visible and current node doesn't match, hide it
                return null;
            }
        }

        return li;
    }

    function hasElementChildren(node) {
        return node.children && node.children.length > 0;
    }

    // --- Tree Node Matching & Filtering ---
    // Collect all descendant text values from a node
    function collectNodeValues(xmlNode) {
        const values = [];
        
        function collectRecursive(node) {
            // Get direct text content
            Array.from(node.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    const text = child.nodeValue.trim();
                    if (text) {
                        values.push(text);
                    }
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    // If it's a leaf element, get its text content
                    if (!hasElementChildren(child)) {
                        const text = child.textContent.trim();
                        if (text) {
                            values.push(text);
                        }
                    } else {
                        // Otherwise recurse
                        collectRecursive(child);
                    }
                }
            });
        }
        
        collectRecursive(xmlNode);
        return values;
    }

    // Check if a node matches the search criteria
    function nodeMatchesSearch(xmlNode, searchText, scope) {
        if (!searchText || searchText.trim() === '') {
            return true; // No search, show all
        }
        
        const searchLower = searchText.toLowerCase().trim();
        
        // Check node name
        const nameMatch = xmlNode.nodeName.toLowerCase().includes(searchLower);
        
        if (scope === 'name') {
            return nameMatch;
        }
        
        // Check values
        const values = collectNodeValues(xmlNode);
        const valueMatch = values.some(val => val.toLowerCase().includes(searchLower));
        
        if (scope === 'value') {
            return valueMatch;
        }
        
        // scope === 'both'
        return nameMatch || valueMatch;
    }

    // Check if node or any of its descendants should be shown
    function shouldShowNode(xmlNode, searchText, scope) {
        if (!searchText || searchText.trim() === '') {
            return true; // No filter
        }
        
        // Check if current node matches
        if (nodeMatchesSearch(xmlNode, searchText, scope)) {
            return true;
        }
        
        // Check if any child matches (recursively)
        if (xmlNode.children) {
            for (let child of xmlNode.children) {
                if (shouldShowNode(child, searchText, scope)) {
                    return true;
                }
            }
        }
        
        return false;
    }

    // --- Sorting Logic ---
    function applySorting(data, state) {
        if (state === 'natural') {
            return data; // Keep original order
        }
        
        const sorted = [...data]; // Create a copy to avoid mutating original
        sorted.sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();
            
            if (state === 'asc') {
                return nameA.localeCompare(nameB);
            } else if (state === 'desc') {
                return nameB.localeCompare(nameA);
            }
            return 0;
        });
        
        return sorted;
    }

    // Sort tree children (XML nodes)
    function sortTreeChildren(children, sortState) {
        // Always convert to array first (HTMLCollection doesn't have forEach)
        const childArray = Array.from(children);
        
        if (sortState === 'natural') {
            return childArray; // Keep original order
        }
        
        childArray.sort((a, b) => {
            const nameA = a.nodeName.toLowerCase();
            const nameB = b.nodeName.toLowerCase();
            
            if (sortState === 'asc') {
                return nameA.localeCompare(nameB);
            } else if (sortState === 'desc') {
                return nameB.localeCompare(nameA);
            }
            return 0;
        });
        
        return childArray;
    }

    // --- Filtering Logic ---
    function applyFiltering(data, text, scope) {
        if (!text || text.trim() === '') {
            return data; // No filter applied
        }
        
        const searchLower = text.toLowerCase().trim();
        
        return data.filter(item => {
            const nameMatch = item.name.toLowerCase().includes(searchLower);
            const valueMatch = item.value.toLowerCase().includes(searchLower);
            
            switch(scope) {
                case 'property':
                    return nameMatch;
                case 'value':
                    return valueMatch;
                case 'both':
                default:
                    return nameMatch || valueMatch;
            }
        });
    }

    function toggleSortState() {
        if (sortState === 'natural') {
            sortState = 'asc';
        } else if (sortState === 'asc') {
            sortState = 'desc';
        } else {
            sortState = 'natural';
        }
    }

    function getSortIndicator() {
        if (sortState === 'asc') {
            return ' <span class="sort-indicator">▲</span>';
        } else if (sortState === 'desc') {
            return ' <span class="sort-indicator">▼</span>';
        }
        return '';
    }

    // --- Detail View Rendering ---
    function showNodeDetails(node) {
        // Save current node for re-rendering on sort
        currentNode = node;
        
        // Show mobile detail panel if on mobile
        if (window.innerWidth <= 768) {
            showDetailMobile();
        }
        
        // Show search bar when details are displayed
        searchBar.classList.add('visible');
        
        // Collect attributes
        const attributes = Array.from(node.attributes || []).map(attr => ({
            name: `@${attr.name}`,
            value: attr.value
        }));

        // Collect direct child text nodes or leaf element nodes
        let directData = [];
        
        // Check for text content directly in this node (mixed content)
        const textContent = Array.from(node.childNodes)
            .filter(n => n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() !== "")
            .map(n => n.nodeValue.trim())
            .join(" ");

        if (textContent) {
            directData.push({ name: '#text', value: textContent });
        }

        // Collect "Leaf" Children (Elements that contain only text)
        Array.from(node.children).forEach(child => {
            if (!hasElementChildren(child)) {
                directData.push({
                    name: child.nodeName,
                    value: child.textContent
                });
            }
        });

        const allData = [...attributes, ...directData];

        if (allData.length === 0) {
            detailContent.innerHTML = `
                <div class="empty-state">
                    <p>${t('noAttributesOrChildren')}</p>
                </div>`;
            updateSearchInfo(0, 0);
            return;
        }

        const path = getNodePath(node);
        
        // Apply filtering first
        const filteredData = applyFiltering(allData, searchText, searchScope);
        
        // Update search info
        updateSearchInfo(filteredData.length, allData.length);
        
        // Then apply sorting
        const sortedData = applySorting(filteredData, sortState);

        let html = `
            <div class="detail-card">
                <div class="card-header">
                    <h2>${node.nodeName}</h2>
                    <div class="path-breadcrumb">${path}</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" id="sort-header">${t('propertyTagHeader')}${getSortIndicator()}</th>
                            <th>${t('valueHeader')}</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        if (sortedData.length === 0) {
            html += `
                <tr>
                    <td colspan="2" style="text-align: center; color: var(--secondary-text); padding: 2rem;">
                        ${t('noMatchingResults')}
                    </td>
                </tr>
            `;
        } else {
            sortedData.forEach((item, index) => {
                const itemPath = path + '.' + item.name.replace(/^@/, '');
                const itemHelp = findHelpContent(itemPath, item.name);
                
                // Validate value
                const validation = itemHelp ? validateValue(item.value, itemHelp) : { valid: true, errors: [] };
                const hasError = !validation.valid;
                const errorClass = hasError ? 'validation-error' : '';
                const hasHelpClass = itemHelp ? 'has-help' : '';
                const errorsJson = hasError ? escapeHtml(JSON.stringify(validation.errors)) : '';
                
                html += `
                    <tr>
                        <td class="attr-name ${hasHelpClass} ${errorClass}" data-item-index="${index}" data-item-name="${escapeHtml(item.name)}" data-item-path="${escapeHtml(itemPath)}" data-errors="${errorsJson}">${escapeHtml(item.name)}</td>
                        <td class="attr-value ${errorClass}">${escapeHtml(item.value)}</td>
                    </tr>
                `;
            });
        }

        html += `
                    </tbody>
                </table>
            </div>
        `;

        detailContent.innerHTML = html;
        
        // Add click handler to sortable header
        const sortHeader = document.getElementById('sort-header');
        if (sortHeader) {
            sortHeader.onclick = () => {
                toggleSortState();
                showNodeDetails(currentNode);
                saveStateToStorage();
            };
        }
        
        // Add hover handlers for tooltips on attribute names (combined help + errors)
        const attrNameCells = detailContent.querySelectorAll('td.attr-name.has-help');
        attrNameCells.forEach(cell => {
            const itemName = cell.dataset.itemName;
            const itemPath = cell.dataset.itemPath;
            const itemHelp = findHelpContent(itemPath, itemName);
            const errorsJson = cell.dataset.errors;
            
            let errors = null;
            if (errorsJson) {
                try {
                    errors = JSON.parse(errorsJson);
                } catch (e) {
                    console.warn('Failed to parse errors:', e);
                }
            }
            
            if (itemHelp || (errors && errors.length > 0)) {
                cell.addEventListener('mouseenter', () => {
                    showTooltip(cell, itemHelp, itemName, errors);
                });
                cell.addEventListener('mouseleave', hideTooltip);
            }
        });
    }

    function updateSearchInfo(filtered, total) {
        if (!searchText || searchText.trim() === '') {
            searchInfo.textContent = '';
        } else {
            searchInfo.textContent = `${t('showingResults')} ${filtered} ${t('of')} ${total} ${t('items')}`;
        }
    }

    function resetDetailView() {
        // Hide search bar when no node is selected
        searchBar.classList.remove('visible');
        searchText = '';
        searchInput.value = '';
        searchInfo.textContent = '';
        
        detailContent.innerHTML = `
            <div class="empty-state">
                <svg style="width: 48px; height: 48px; margin-bottom: 1rem; opacity: 0.5;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <p>${escapeHtml(t('selectNode'))}</p>
            </div>`;
    }

    function getNodePath(node) {
        const path = [];
        let current = node;
        while (current && current.nodeType === Node.ELEMENT_NODE) {
            path.unshift(current.nodeName);
            current = current.parentNode;
        }
        return path.join('.');
    }

    // Restore node selection after re-rendering tree
    function restoreNodeSelection(path) {
        if (!path) return;
        
        // Find the tree node with matching path
        const treeNodes = treeContainer.querySelectorAll('.tree-node');
        for (let treeNode of treeNodes) {
            if (treeNode.dataset.nodePath === path) {
                const content = treeNode.querySelector('.tree-content');
                if (content) {
                    content.classList.add('selected');
                    // Scroll into view if needed
                    content.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
                break;
            }
        }
    }

    function escapeHtml(text) {
        if (!text) return '';
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // --- LocalStorage Persistence ---
    function saveStateToStorage() {
        try {
            // Save XML content and filename
            if (xmlRawContent) {
                localStorage.setItem(STORAGE_KEYS.XML_CONTENT, xmlRawContent);
            }
            if (xmlFilename) {
                localStorage.setItem(STORAGE_KEYS.XML_FILENAME, xmlFilename);
            }
            
            // Save tree panel states
            localStorage.setItem(STORAGE_KEYS.TREE_SEARCH_TEXT, treeSearchText);
            localStorage.setItem(STORAGE_KEYS.TREE_SEARCH_SCOPE, treeSearchScope);
            localStorage.setItem(STORAGE_KEYS.TREE_SORT_STATE, treeSortState);
            localStorage.setItem(STORAGE_KEYS.TREE_EXPANDED, JSON.stringify(treeExpanded));
            
            // Save selected node path
            if (currentNodePath) {
                localStorage.setItem(STORAGE_KEYS.SELECTED_NODE_PATH, currentNodePath);
            } else {
                localStorage.removeItem(STORAGE_KEYS.SELECTED_NODE_PATH);
            }
            
            // Save detail panel states
            localStorage.setItem(STORAGE_KEYS.DETAIL_SEARCH_TEXT, searchText);
            localStorage.setItem(STORAGE_KEYS.DETAIL_SEARCH_SCOPE, searchScope);
            localStorage.setItem(STORAGE_KEYS.DETAIL_SORT_STATE, sortState);
            
            // Save help schema
            if (helpSchemaRaw) {
                localStorage.setItem(STORAGE_KEYS.HELP_SCHEMA, helpSchemaRaw);
            }
            if (helpSchemaFilename) {
                localStorage.setItem(STORAGE_KEYS.HELP_SCHEMA_FILENAME, helpSchemaFilename);
            }
            
            // Save current view state
            localStorage.setItem(STORAGE_KEYS.CURRENT_VIEW, currentView);
            
            // Save theme and language
            localStorage.setItem(STORAGE_KEYS.CURRENT_THEME, currentTheme);
            localStorage.setItem(STORAGE_KEYS.CURRENT_LANG, currentLang);
        } catch (e) {
            console.warn('Failed to save state to localStorage:', e);
            // localStorage might be full or disabled
        }
    }

    function restoreStateFromStorage() {
        try {
            // Restore theme and language first
            const savedTheme = localStorage.getItem(STORAGE_KEYS.CURRENT_THEME);
            const savedLang = localStorage.getItem(STORAGE_KEYS.CURRENT_LANG);
            
            if (savedTheme) {
                currentTheme = savedTheme;
                document.documentElement.setAttribute('data-theme', currentTheme);
            } else {
                // Default to light theme
                currentTheme = 'light';
                document.documentElement.setAttribute('data-theme', 'light');
            }
            
            // Update theme toggle icon
            const themeIcon = document.getElementById('theme-icon');
            if (themeIcon) {
                themeIcon.textContent = currentTheme === 'dark' ? 'light_mode' : 'dark_mode';
            }
            
            if (savedLang) {
                currentLang = savedLang;
            } else {
                // Detect browser language or default to Chinese
                const browserLang = navigator.language || navigator.userLanguage;
                currentLang = browserLang.startsWith('zh') ? 'zh' : 'zh'; // Default to zh as specified
            }
            
            // Apply translations
            applyTranslations();
            
            // Restore help schema first (before rendering)
            const savedHelpSchema = localStorage.getItem(STORAGE_KEYS.HELP_SCHEMA);
            const savedHelpSchemaFilename = localStorage.getItem(STORAGE_KEYS.HELP_SCHEMA_FILENAME);
            if (savedHelpSchema) {
                try {
                    const parsed = JSON.parse(savedHelpSchema);
                    helpSchema = processHelpSchema(parsed);
                    helpSchemaRaw = savedHelpSchema;
                    helpSchemaFilename = savedHelpSchemaFilename || 'help-schema.json';
                    
                    // Update UI
                    helpUploadBtn.classList.add('loaded');
                    helpStatusText.textContent = helpSchemaFilename;
                    helpStatusText.title = helpSchemaFilename;
                } catch (e) {
                    console.warn('Failed to restore help schema:', e);
                }
            }
            
            // Restore XML content
            const savedXmlContent = localStorage.getItem(STORAGE_KEYS.XML_CONTENT);
            const savedFilename = localStorage.getItem(STORAGE_KEYS.XML_FILENAME);
            
            // Restore tree panel states first (before rendering)
            const savedTreeSearchText = localStorage.getItem(STORAGE_KEYS.TREE_SEARCH_TEXT);
            const savedTreeSearchScope = localStorage.getItem(STORAGE_KEYS.TREE_SEARCH_SCOPE);
            const savedTreeSortState = localStorage.getItem(STORAGE_KEYS.TREE_SORT_STATE);
            const savedTreeExpanded = localStorage.getItem(STORAGE_KEYS.TREE_EXPANDED);
            
            // Restore detail panel states
            const savedDetailSearchText = localStorage.getItem(STORAGE_KEYS.DETAIL_SEARCH_TEXT);
            const savedDetailSearchScope = localStorage.getItem(STORAGE_KEYS.DETAIL_SEARCH_SCOPE);
            const savedDetailSortState = localStorage.getItem(STORAGE_KEYS.DETAIL_SORT_STATE);
            
            // Restore selected node path
            const savedNodePath = localStorage.getItem(STORAGE_KEYS.SELECTED_NODE_PATH);
            
            // Restore current view state
            const savedCurrentView = localStorage.getItem(STORAGE_KEYS.CURRENT_VIEW);
            
            // Apply tree panel states
            if (savedTreeSearchText !== null) {
                treeSearchText = savedTreeSearchText;
                treeSearchInput.value = savedTreeSearchText;
            }
            if (savedTreeSearchScope !== null) {
                treeSearchScope = savedTreeSearchScope;
                const treeRadio = document.querySelector(`input[name="tree-search-scope"][value="${savedTreeSearchScope}"]`);
                if (treeRadio) treeRadio.checked = true;
            }
            if (savedTreeSortState !== null) {
                treeSortState = savedTreeSortState;
                // Update sort icon
                if (treeSortState === 'asc') {
                    treeSortIcon.textContent = '▲';
                } else if (treeSortState === 'desc') {
                    treeSortIcon.textContent = '▼';
                } else {
                    treeSortIcon.textContent = '↕';
                }
            }
            if (savedTreeExpanded !== null) {
                treeExpanded = JSON.parse(savedTreeExpanded);
                // Update toggle button
                if (treeExpanded) {
                    treeToggleIcon.textContent = '⊟';
                    treeToggleText.textContent = '折叠';
                } else {
                    treeToggleIcon.textContent = '⊞';
                    treeToggleText.textContent = '展开';
                }
            }
            
            // Apply detail panel states
            if (savedDetailSearchText !== null) {
                searchText = savedDetailSearchText;
                searchInput.value = savedDetailSearchText;
            }
            if (savedDetailSearchScope !== null) {
                searchScope = savedDetailSearchScope;
                const detailRadio = document.querySelector(`input[name="search-scope"][value="${savedDetailSearchScope}"]`);
                if (detailRadio) detailRadio.checked = true;
            }
            if (savedDetailSortState !== null) {
                sortState = savedDetailSortState;
            }
            
            // Restore selected node path (will be used when tree is rendered)
            if (savedNodePath !== null) {
                currentNodePath = savedNodePath;
            }
            
            // If we have saved XML content, parse and render it
            if (savedXmlContent) {
                xmlRawContent = savedXmlContent;
                xmlFilename = savedFilename || 'Restored file';
                
                // Update drop zone text
                dropZoneText.textContent = xmlFilename;
                
                // Parse the XML
                const parser = new DOMParser();
                const parsedDoc = parser.parseFromString(savedXmlContent, "text/xml");
                
                // Check for parser errors
                const parserError = parsedDoc.getElementsByTagName("parsererror")[0] || 
                                    parsedDoc.querySelector("parsererror");
                if (parserError) {
                    console.warn("Failed to restore XML from localStorage - parse error");
                    clearStoredState();
                    return;
                }
                
                // Check if we have a valid document element
                if (!parsedDoc.documentElement || parsedDoc.documentElement.nodeName === "html") {
                    console.warn("Failed to restore XML from localStorage - invalid structure");
                    clearStoredState();
                    return;
                }
                
                // Store and render
                xmlDoc = parsedDoc;
                renderTree(xmlDoc);
                
                // Apply expand/collapse state to all nodes after rendering
                if (treeExpanded) {
                    const treeNodes = treeContainer.querySelectorAll('.tree-node:not(.leaf-node)');
                    treeNodes.forEach(node => {
                        node.classList.add('expanded');
                    });
                }
                
                // Restore selected node and show its details
                if (currentNodePath && xmlDoc) {
                    const xmlNode = findXmlNodeByPath(xmlDoc, currentNodePath);
                    if (xmlNode) {
                        currentNode = xmlNode;
                        showNodeDetails(xmlNode);
                        
                        // Also highlight the node in the tree
                        setTimeout(() => {
                            restoreNodeSelection(currentNodePath);
                            // Highlight parent path
                            highlightParentPath(currentNodePath);
                        }, 0);
                    }
                }
                
                // Restore view state (tree vs xml)
                if (savedCurrentView && savedCurrentView !== 'tree') {
                    // Switch to saved view
                    currentView = savedCurrentView;
                    viewTabs.forEach(tab => {
                        tab.classList.toggle('active', tab.dataset.view === savedCurrentView);
                    });
                    treeViewContainer.classList.toggle('active', savedCurrentView === 'tree');
                    xmlViewContainer.classList.toggle('active', savedCurrentView === 'xml');
                    
                    // If XML view, render it
                    if (savedCurrentView === 'xml') {
                        renderXmlView();
                    }
                }
            }
        } catch (e) {
            console.warn('Failed to restore state from localStorage:', e);
        }
    }

    function clearStoredState() {
        Object.values(STORAGE_KEYS).forEach(key => {
            localStorage.removeItem(key);
        });
    }

    // Find XML node by path (e.g., "root.parent.child")
    function findXmlNodeByPath(doc, path) {
        if (!path || !doc) return null;
        
        const parts = path.split('.');
        let current = doc.documentElement;
        
        // First part should be the root element
        if (parts[0] !== current.nodeName) return null;
        
        // Traverse the path
        for (let i = 1; i < parts.length; i++) {
            const targetName = parts[i];
            let found = false;
            
            for (let child of current.children) {
                if (child.nodeName === targetName) {
                    current = child;
                    found = true;
                    break;
                }
            }
            
            if (!found) return null;
        }
        
        return current;
    }

    // Highlight parent path in tree after restore
    function highlightParentPath(path) {
        if (!path) return;
        
        const treeNodes = treeContainer.querySelectorAll('.tree-node');
        const parts = path.split('.');
        
        // Build all parent paths
        const parentPaths = [];
        for (let i = 1; i < parts.length; i++) {
            parentPaths.push(parts.slice(0, i).join('.'));
        }
        
        // Highlight parent nodes and expand them
        treeNodes.forEach(treeNode => {
            const nodePath = treeNode.dataset.nodePath;
            if (parentPaths.includes(nodePath)) {
                const content = treeNode.querySelector(':scope > .tree-content');
                if (content) {
                    content.classList.add('parent-path');
                }
                // Ensure parent is expanded
                treeNode.classList.add('expanded');
            }
        });
    }

    // --- Initialize: Restore state on page load ---
    restoreStateFromStorage();

    // =============================================
    // Additional Tauri Functions (Save, Menu Integration)
    // =============================================
    
    if (isTauri && tauriInvoke) {
        // Save XML file
        window.tauriSaveFile = async function() {
            if (!xmlRawContent) {
                await tauriDialogMessage('没有可保存的内容', { title: 'Warning', kind: 'warning' });
                return;
            }
            
            try {
                if (currentFilePath) {
                    // Save to existing path
                    await tauriWriteTextFile(currentFilePath, xmlRawContent);
                    await tauriDialogMessage('文件已保存', { title: 'Success', kind: 'info' });
                } else {
                    // No path, use Save As
                    await window.tauriSaveFileAs();
                }
            } catch (err) {
                console.error('Error saving file:', err);
                await tauriDialogMessage('保存文件失败: ' + err.message, { title: 'Error', kind: 'error' });
            }
        };
        
        // Save As
        window.tauriSaveFileAs = async function() {
            if (!xmlRawContent) {
                await tauriDialogMessage('没有可保存的内容', { title: 'Warning', kind: 'warning' });
                return;
            }
            
            try {
                const filePath = await tauriDialogSave({
                    filters: [{
                        name: 'XML Files',
                        extensions: ['xml']
                    }],
                    defaultPath: xmlFilename || 'document.xml'
                });
                
                if (filePath) {
                    await tauriWriteTextFile(filePath, xmlRawContent);
                    currentFilePath = filePath;
                    
                    // Update filename
                    const filename = filePath.split('/').pop().split('\\').pop();
                    xmlFilename = filename;
                    dropZoneText.textContent = filename;
                    
                    await tauriDialogMessage('文件已保存', { title: 'Success', kind: 'info' });
                }
            } catch (err) {
                console.error('Error saving file:', err);
                await tauriDialogMessage('保存文件失败: ' + err.message, { title: 'Error', kind: 'error' });
            }
        };
        
        // --- Tree View Controls (for menu integration) ---
        
        window.expandAllNodes = function() {
            treeExpanded = true;
            treeToggleIcon.textContent = '⊟';
            treeToggleText.textContent = '折叠';
            
            const treeNodes = treeContainer.querySelectorAll('.tree-node:not(.leaf-node)');
            treeNodes.forEach(node => node.classList.add('expanded'));
            saveStateToStorage();
        };
        
        window.collapseAllNodes = function() {
            treeExpanded = false;
            treeToggleIcon.textContent = '⊞';
            treeToggleText.textContent = '展开';
            
            const treeNodes = treeContainer.querySelectorAll('.tree-node:not(.leaf-node)');
            treeNodes.forEach(node => node.classList.remove('expanded'));
            saveStateToStorage();
        };
        
        window.toggleTreePanel = function() {
            const treePanel = document.getElementById('tree-panel');
            if (treePanel) {
                treePanel.style.display = treePanel.style.display === 'none' ? 'flex' : 'none';
            }
        };
        
        // --- About Dialog ---
        
        window.showAboutDialog = async function() {
            await tauriDialogMessage(
                'XML Navigator v1.0.0\n\n' +
                '一个现代化的 XML 文件浏览器和编辑器\n' +
                '支持树形视图、语法高亮和帮助配置验证\n\n' +
                'Built with Tauri + Monaco Editor',
                { title: 'About XML Navigator', kind: 'info' }
            );
        };
        
        // --- Auto Update ---
        
        window.checkForUpdates = async function() {
            try {
                // Tauri v2 updater API
                const tauriUpdater = window.__TAURI__.updater;
                if (tauriUpdater && tauriUpdater.check) {
                    const update = await tauriUpdater.check();
                    if (update && update.available) {
                        const shouldUpdate = await tauriDialogAsk(
                            `发现新版本 ${update.version}，是否现在更新？`,
                            { title: 'Update Available', kind: 'info' }
                        );
                    
                        if (shouldUpdate) {
                            await update.downloadAndInstall();
                        }
                    } else {
                        await tauriDialogMessage('当前已是最新版本', { title: 'Check for Updates', kind: 'info' });
                    }
                } else {
                    await tauriDialogMessage('更新功能未配置', { title: 'Info', kind: 'info' });
                }
            } catch (err) {
                console.error('Update check failed:', err);
                await tauriDialogMessage('检查更新失败: ' + err.message, { title: 'Error', kind: 'error' });
            }
        };
    }
</script>

</body>
</html>